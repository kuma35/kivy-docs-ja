# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: Kivy 2.2.0.dev0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-12 08:37+0900\n"
"PO-Revision-Date: 2023-02-03 02:18+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../sources/guide/inputs.rst:2
msgid "Input management"
msgstr "Input management"

#: ../../sources/guide/inputs.rst:5
msgid "Input architecture"
msgstr "Input architecture"

#: ../../sources/guide/inputs.rst:7
msgid ""
"Kivy is able to handle most types of input: mouse, touchscreen, "
"accelerometer, gyroscope, etc. It handles the native multitouch protocols"
" on the following platforms: Tuio, WM_Touch, MacMultitouchSupport, MT "
"Protocol A/B and Android."
msgstr "Kivy は、 ほとんどのタイプの入力を扱う事ができます。 それは、 マウスやタッチ・スクリーンや加速度計やジャイロスコープなどです。 Tuio や WM_Touch や MacMultitouchSupport や  MT Protocol A/B や Android の、各プラットフォームでネイティブ・マルチタッチ・プロトコルを扱います。"

#: ../../sources/guide/inputs.rst:11
msgid "The global architecture can be viewed as::"
msgstr "おおまかなアーキテクチャは以下のようになります::"

#: ../../sources/guide/inputs.rst:15
msgid ""
"The class of all input events is the "
":class:`~kivy.input.motionevent.MotionEvent`. It generates 2 kinds of "
"events:"
msgstr "すべての入力イベントのクラスは :class:`~kivy.input.motionevent.MotionEvent` です。 これは 2 種類のイベントを生成します:"

#: ../../sources/guide/inputs.rst:19
msgid ""
"Touch events: a motion event that contains at least an X and Y position. "
"All the touch events are dispatched across the Widget tree."
msgstr "touch イベント: 少なくとも X と Y の位置を含むモーション・イベント(motion event)。 すべての touch イベントは、 ウィジェット・ツリー全体に発送(dispatch)されます。"

#: ../../sources/guide/inputs.rst:21
msgid ""
"No-touch events: all the rest. For example, the accelerometer is a "
"continuous event, without position. It never starts or stops. These "
"events are not dispatched across the Widget tree."
msgstr "no-touch イベント: touch イベント以外のすべて。 たとえば、 加速度計は位置のない連続イベント(continuous event)です。 開始(starts)も停止(stops)もありません。 これらのイベントは、 ウィジェット・ツリー全体に発送(dispatch)しません。"

#: ../../sources/guide/inputs.rst:26
msgid ""
"A Motion event is generated by an :mod:`Input Provider "
"<kivy.input.providers>`. An Input Provider is responsible for reading the"
" input event from the operating system, the network or even from another "
"application. Several input providers exist, such as:"
msgstr "モーション・イベント(Motion event)は :mod:`Input Provider <kivy.input.providers>` (入力プロバイダー)によって生成されます。 入力プロバイダーは、 オペレーティング・システムまたはネットワークまたは別のアプリケーションから入力イベントを読み取る役割を果たします。 以下のようないくつかの入力プロバイダーが存在します:"

#: ../../sources/guide/inputs.rst:31
msgid ""
":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create a UDP"
" server and listen for TUIO/OSC messages."
msgstr ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: UDP サーバーを作成し、TUIO/OSC メッセージをリッスンします。"

#: ../../sources/guide/inputs.rst:33
msgid ""
":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the "
"windows API for reading multitouch information and sending it to Kivy."
msgstr ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: Windows API を使用してマルチタッチ情報を読み取り、 Kivy に送ります。"

#: ../../sources/guide/inputs.rst:35
msgid ""
":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: In "
"Linux, iterate over all the hardware connected to the computer, and "
"attaches a multitouch input provider for each multitouch device found."
msgstr ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: Linux では、 コンピューターに接続されているすべてのハードウェアに対して繰り返し処理して見つかったマルチタッチ・デバイス毎に、 マルチタッチ入力プロバイダーを当て嵌めますます。"

#: ../../sources/guide/inputs.rst:38
msgid "and much more!"
msgstr "などなど…"

#: ../../sources/guide/inputs.rst:40
msgid ""
"When you write an application, you don't need to create an input "
"provider. Kivy tries to automatically detect available hardware. However,"
" if you want to support custom hardware, you will need to configure kivy "
"to make it work."
msgstr "アプリケーションを作成するときに、 あなたが入力プロバイダーを作成する必要はありません。 Kivy は利用可能なハードウェアを自動的に検出しようとします。 ただし、カスタム・ハードウェアをサポートしたい場合は、 それが動作するように kivy を構成する必要があります。"

#: ../../sources/guide/inputs.rst:44
msgid ""
"Before the newly-created Motion Event is passed to the user, Kivy applies"
" post-processing to the input. Every motion event is analyzed to detect "
"and correct faulty input, as well as make meaningful interpretations "
"like:"
msgstr "新しく作成されたモーション・イベントがユーザーに渡される前に、 Kivy は後処理(post-processing)を入力に適用します。 すべてのモーション・イベントを分析して、 誤った入力を検出して修正し、 以下のような意味のある動作を見出します。"

#: ../../sources/guide/inputs.rst:48
msgid "Double/triple-tap detection, according to a distance and time threshold"
msgstr "距離と時間のしきい値による ダブルタップ/トリプルタップ 検出"

#: ../../sources/guide/inputs.rst:49
msgid "Making events more accurate when the hardware is not accurate"
msgstr "ハードウェアが的確でない場合にイベントをより的確にする"

#: ../../sources/guide/inputs.rst:50
msgid ""
"Reducing the amount of generated events if the native touch hardware is "
"sending events with nearly the same position"
msgstr "ネイティブ・タッチ・ハードウェアがほぼ同一の位置でイベントを送信している場合、 生成されるイベントの量を減らす"

#: ../../sources/guide/inputs.rst:53
msgid ""
"After processing, the motion event is dispatched to the Window. As "
"explained previously, not all events are dispatched to the whole widget "
"tree: the window filters them. For a given event:"
msgstr "処理後、モーション・イベントが Window に発送(dispatch)されます。 以前に説明したように、 すべてのイベントがウィジェット・ツリー全体に発送(dispatch)されるわけではありません。 ウィンドウはそれらをフィルタリングします。 以下のイベントが与えられた場合:"

#: ../../sources/guide/inputs.rst:57
msgid ""
"if it's only a motion event, it will be dispatched to "
":meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr "モーション・イベントのみの場合、 :meth:`~kivy.core.window.WindowBase.on_motion` に発送(dispatch)されます"

#: ../../sources/guide/inputs.rst:59
msgid ""
"if it's a touch event, the (x,y) position of the touch (0-1 range) will "
"be scaled to the Window size (width/height), and dispatched to:"
msgstr "タッチ・イベントの場合、 タッチの (x,y) 位置 (0 ～ 1 の範囲) がウィンドウ・サイズ (幅/高さ) に比例して拡大(scale)され、 以下に発送(dispatch)されます:"

#: ../../sources/guide/inputs.rst:62
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ":meth:`~kivy.uix.widget.Widget.on_touch_down`"

#: ../../sources/guide/inputs.rst:63
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ":meth:`~kivy.uix.widget.Widget.on_touch_move`"

#: ../../sources/guide/inputs.rst:64
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ":meth:`~kivy.uix.widget.Widget.on_touch_up`"

#: ../../sources/guide/inputs.rst:68
msgid "Motion event profiles"
msgstr "Motion event profiles"

#: ../../sources/guide/inputs.rst:70
msgid ""
"Depending on your hardware and the input providers used, more information"
" may be made available to you. For example, a touch input has an (x,y) "
"position, but might also have pressure information, blob size, an "
"acceleration vector, etc."
msgstr "あなたのハードウェアや使用する入力プロバイダーによっては、 より多くの情報を利用できる場合があります。 たとえば、 touch 入力には (x,y) 位置がありますが、圧力情報やブロブ・サイズや加速度ベクトルなども含まれる場合があります。"

#: ../../sources/guide/inputs.rst:74
msgid ""
"A profile is a string that indicates what features are available inside "
"the motion event. Let's imagine that you are in an ``on_touch_move`` "
"method::"
msgstr "プロファイルは、 モーション・イベント内で使用できる機能を示す文字列です。 あなたが ``on_touch_move`` メソッド内にいると想像してみましょう::"

#: ../../sources/guide/inputs.rst:81
msgid "The print could output::"
msgstr "これは以下を出力します::"

#: ../../sources/guide/inputs.rst:87
msgid ""
"Many people mix up the profile's name and the name of the corresponding "
"property. Just because ``'angle'`` is in the available profile doesn't "
"mean that the touch event object will have an ``angle`` property."
msgstr "多くの人が、プロファイルの名前と対応するプロパティの名前を混同しています。 ``'angle'`` が利用可能なプロファイルにあるからといって、 タッチ・イベント・オブジェクトが ``angle`` プロパティを持つことを意味するわけではありません。"

#: ../../sources/guide/inputs.rst:91
msgid ""
"For the ``'pos'`` profile, the properties ``pos``, ``x``, and ``y`` will "
"be available. With the ``'angle'`` profile, the property ``a`` will be "
"available. As we said, for touch events ``'pos'`` is a mandatory profile,"
" but not ``'angle'``. You can extend your interaction by checking if the "
"``'angle'`` profile exists::"
msgstr "``'pos'`` プロファイルの場合、 プロパティ ``pos`` と ``x`` と ``y`` が利用可能になります。 ``'angle'`` プロファイルでは、 プロパティ ``a`` が利用可能になります。  前述したように、 touch イベントでは ``'pos'`` は必須のプロファイルですが、 ``'angle'``  は必須ではありません。 ``'angle'`` プロファイルが存在するかどうかを確認することで、 あなたのインタラクションを拡張できます::"

#: ../../sources/guide/inputs.rst:102
msgid ""
"You can find a list of available profiles in the "
":mod:`~kivy.input.motionevent` documentation."
msgstr "利用可能なプロファイルのリストは :mod:`~kivy.input.motionevent` ドキュメント にあります。"

#: ../../sources/guide/inputs.rst:106
msgid "Touch events"
msgstr "Touch events"

#: ../../sources/guide/inputs.rst:108
msgid ""
"A touch event is a specialized "
":class:`~kivy.input.motionevent.MotionEvent` where the property "
":attr:`~kivy.input.motionevent.MotionEvent.is_touch` evaluates to True. "
"For all touch events, you automatically have the X and Y positions "
"available, scaled to the Window width and height. In other words, all "
"touch events have the ``'pos'`` profile."
msgstr "タッチ・イベントは特殊化(specialized)された :class:`~kivy.input.motionevent.MotionEvent` で、 プロパティ :attr:`~kivy.input.motionevent.MotionEvent.is_touch` が True と評価されます。 すべてのタッチ・イベントにおいて、X と Y の位置が自動的に使用可能になり、その位置はウィンドウの幅と高さに合わせてスケーリングされます。 言い換えると、 すべてのタッチ・イベントには ``'pos'`` プロファイルがあります。"

#: ../../sources/guide/inputs.rst:115
msgid "Touch event basics"
msgstr "Touch event basics"

#: ../../sources/guide/inputs.rst:117
msgid ""
"By default, touch events are dispatched to all currently displayed "
"widgets. This means widgets receive the touch event whether it occurs "
"within their physical area or not."
msgstr "デフォルトでは、 タッチ・イベントは現在表示されているすべてのウィジェットに発送(dispatch)されます。  つまり、 ウィジェットは、 物理領域(physical area)内で発生したかどうかに関係なく、 タッチ・イベントを受け取ります。"

#: ../../sources/guide/inputs.rst:121
msgid ""
"This can be counter intuitive if you have experience with other GUI "
"toolkits. These typically divide the screen into geometric areas and only"
" dispatch touch or mouse events to the widget if the coordinate lies "
"within the widgets area."
msgstr "他の GUI ツールキットの経験がある場合、これはあなたの直感に反する可能性があります。  他の GUI ツールキットでは通常、 画面を幾何学的な領域に分割し、 座標がウィジェット領域内にある場合にのみ、 タッチ・イベントまたはマウス・イベントをウィジェットに発送(dispatch)します。"

#: ../../sources/guide/inputs.rst:126
msgid ""
"This requirement becomes very restrictive when working with touch input. "
"Swipes, pinches and long presses may well originate from outside of the "
"widget that wants to know about them and react to them."
msgstr "この要件は、タッチ入力で作業する場合には非常に制限されたものとなります。 スワイプやピンチや長押しは、 それらについて知り、 そして、 それらに反応したいウィジェットの外部がその源である可能性があります。"

#: ../../sources/guide/inputs.rst:130
msgid ""
"In order to provide the maximum flexibility, Kivy dispatches the events "
"to all the widgets and lets them decide how to react to them. If you only"
" want to respond to touch events inside the widget, you simply check::"
msgstr "最大限の柔軟性を提供するために、 Kivy はイベントをすべてのウィジェットに発送(dispatch)し、 ウィジェットにどのように反応するかを決定させます。 ウィジェット内のタッチ・イベントにのみ応答させたい場合、 あなたは以下を確認するだけです::"

#: ../../sources/guide/inputs.rst:141
msgid "Coordinates"
msgstr "Coordinates"

# scatter plot matrix;散布図変換
#: ../../sources/guide/inputs.rst:143
msgid ""
"You must take care of matrix transformation in your touch as soon as you "
"use a widget with matrix transformation. Some widgets such as "
":class:`~kivy.uix.scatter.Scatter` have their own matrix transformation, "
"meaning the touch must be multiplied by the scatter matrix to be able to "
"correctly dispatch touch positions to the Scatter's children."
msgstr "行列変換(matrix transformation)を伴うウィジェットを使用する場合は、 直ちにあなたのタッチで行列変換の処理を行う必要があります。 :class:`~kivy.uix.scatter.Scatter` などの一部のウィジェットには、 独自の行列変換があります。 つまり、Scatter の子にタッチ位置を正しく発送(dispatch)するには、 タッチに散布行列(scatter matrix)を乗算する必要があります。"

#: ../../sources/guide/inputs.rst:150
msgid ""
"Get coordinate from parent space to local space: "
":meth:`~kivy.uix.widget.Widget.to_local`"
msgstr "親空間からローカル空間への変換座標を取得: :meth:`~kivy.uix.widget.Widget.to_local`"

#: ../../sources/guide/inputs.rst:152
msgid ""
"Get coordinate from local space to parent space: "
":meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr "ローカル空間から親空間への変換座標を取得: :meth:`~kivy.uix.widget.Widget.to_parent`"

#: ../../sources/guide/inputs.rst:154
msgid ""
"Get coordinate from local space to window space: "
":meth:`~kivy.uix.widget.Widget.to_window`"
msgstr "ローカル空間からウィンドウ空間への変換座標を取得: :meth:`~kivy.uix.widget.Widget.to_window`"

#: ../../sources/guide/inputs.rst:156
msgid ""
"Get coordinate from window space to local space: "
":meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr "ウィンドウ空間からローカル空間への変換座標を取得: :meth:`~kivy.uix.widget.Widget.to_widget`"

#: ../../sources/guide/inputs.rst:159
msgid ""
"You must use one of them to scale coordinates correctly to the context. "
"Let's look the scatter implementation::"
msgstr "座標をコンテキストに合わせて正しくスケーリングするには、 これらのいずれかを使用する必要があります。 それでは scatter の実装を見てみましょう::"

#: ../../sources/guide/inputs.rst:182
msgid "Touch shapes"
msgstr "Touch shapes"

#: ../../sources/guide/inputs.rst:184
msgid ""
"If the touch has a shape, it will be reflected in the 'shape' property. "
"Right now, only a :class:`~kivy.input.shape.ShapeRect` can be exposed::"
msgstr "タッチがshape(形状)を持つ場合、 'shape' プロパティに反映されます。 現在お披露目できるのは :class:`~kivy.input.shape.ShapeRect` だけです::"

#: ../../sources/guide/inputs.rst:196
msgid "Double tap"
msgstr "Double tap"

#: ../../sources/guide/inputs.rst:198
msgid ""
"A double tap is the action of tapping twice within a time and a distance."
" It's calculated by the doubletap post-processing module. You can test if"
" the current touch is one of a double tap or not::"
msgstr "ダブル・タップとは、 一定時間内に 2 回タップする動作です。 ダブル・タップ後処理モジュール(doubletap post-processing)によって計算されます。 あなたは以下のようにして現在のタッチがダブル・タップかどうかをテストできます::"

#: ../../sources/guide/inputs.rst:210
msgid "Triple tap"
msgstr "Triple tap"

#: ../../sources/guide/inputs.rst:212
msgid ""
"A triple tap is the action of tapping thrice within a time and a "
"distance. It's calculated by the tripletap post-processing module. You "
"can test if the current touch is one of a triple tap or not::"
msgstr "トリプル・タップとは、一定時間内に 3 回タップするアクションです。 これは、トリプルタップ後処理モジュール(tripletap post-processing module)によって計算されます。 あなたは以下のようにして現在のタッチがトリプル・タップかどうかをテストできます::"

#: ../../sources/guide/inputs.rst:224
msgid "Grabbing touch events"
msgstr "Grabbing touch events"

#: ../../sources/guide/inputs.rst:226
msgid ""
"It's possible for the parent widget to dispatch a touch event to a child "
"widget from within ``on_touch_down``, but not from ``on_touch_move`` or "
"``on_touch_up``. This can happen in certain scenarios, like when a touch "
"movement is outside the bounding box of the parent, so the parent decides"
" not to notify its children of the movement."
msgstr "親ウィジェットが ``on_touch_down`` 内から子ウィジェットにタッチ・イベントを発送(dispatch)することは可能なのに、 ``on_touch_move`` や ``on_touch_up`` からは発送(dispatch)不能な事があります。 例えば、これは、 タッチが親の枠の外へ動いて、 親がその動きを子に通知しないことに決めた場合など、 特定のシナリオで起こることがあります。"

#: ../../sources/guide/inputs.rst:232
msgid ""
"But you might want to do something in ``on_touch_up``. Say you started "
"something in the ``on_touch_down`` event, like playing a sound, and you'd"
" like to finish things on the ``on_touch_up`` event. Grabbing is what you"
" need."
msgstr "しかし、 あなたは ``on_touch_up`` で何かをしたいかもしれません。 ``on_touch_down`` イベントで音を鳴らすなどの何かを開始し、 ``on_touch_up`` イベントで何かを終了したいとします。 グラブ(Grabbing;掴んだままにする意)が、 あなたが必要とするものです。"

#: ../../sources/guide/inputs.rst:236
msgid ""
"When you grab a touch, you will always receive the move and up event. But"
" there are some limitations to grabbing:"
msgstr "あなたがタッチをグラブする、 あなたは必ず move と up イベントを受け取ります。 ただし、グラブにはいくつかの制限があります:"

#: ../../sources/guide/inputs.rst:239
msgid ""
"You will receive the event at least twice: one time from your parent (the"
" normal event), and one time from the window (grab)."
msgstr "あなたは少なくとも 2 回イベントを受け取ります。1 回は親から (通常のイベント)、もう 1 回はウィンドウから (グラブ) です。"

#: ../../sources/guide/inputs.rst:241
msgid ""
"You might receive an event with a grabbed touch, but not from you: it can"
" be because the parent has sent the touch to its children while it was in"
" the grabbed state."
msgstr "あなたがグラブされたタッチでイベントを受け取る場合だけど、 あなた自身がグラブしたのでは無い場合。これは、グラブ状態のときに親が子にタッチを送信したことが原因である可能性があります。"

#: ../../sources/guide/inputs.rst:245
msgid "Here is an example of how to use grabbing::"
msgstr "グラブの使用例を以下に示します::"

#: ../../sources/guide/inputs.rst:272
msgid "Touch Event Management"
msgstr "Touch Event Management"

#: ../../sources/guide/inputs.rst:274
msgid ""
"In order to see how touch events are controlled and propagated between "
"widgets, please refer to the :ref:`Widget touch event bubbling <widget-"
"event-bubbling>` section."
msgstr "ウィジェット間でタッチ・イベントがどのように制御(control)および伝達(propagate)されるかを確認するには、 :ref:`Widget touch event bubbling <widget-event-bubbling>` セクションを参照してください。"

#: ../../sources/guide/inputs.rst:279
msgid "Joystick events"
msgstr "Joystick events"

#: ../../sources/guide/inputs.rst:281
msgid ""
"A joystick input represents raw values received directly from physical or"
" virtual controllers through the SDL2 provider via these events:"
msgstr "ジョイスティック入力は、 以下のイベントを介して SDL2 プロバイダーを介して物理(physical)または仮想(virtual)コントローラーから直接受信した生の値を表します:"

#: ../../sources/guide/inputs.rst:284
msgid "SDL_JOYAXISMOTION"
msgstr "SDL_JOYAXISMOTION"

#: ../../sources/guide/inputs.rst:285
msgid "SDL_JOYHATMOTION"
msgstr "SDL_JOYHATMOTION"

#: ../../sources/guide/inputs.rst:286
msgid "SDL_JOYBALLMOTION"
msgstr "SDL_JOYBALLMOTION"

#: ../../sources/guide/inputs.rst:287
msgid "SDL_JOYBUTTONDOWN"
msgstr "SDL_JOYBUTTONDOWN"

#: ../../sources/guide/inputs.rst:288
msgid "SDL_JOYBUTTONUP"
msgstr "SDL_JOYBUTTONUP"

#: ../../sources/guide/inputs.rst:290
msgid ""
"Every motion event has a minimum, maximum and default value which can "
"reach:"
msgstr "すべてのモーション・イベントには、 以下のとおり、 到達可能な最小値と最大値とフォルト値があります。"

#: ../../sources/guide/inputs.rst:294
msgid "Event"
msgstr "イベント"

#: ../../sources/guide/inputs.rst:294
msgid "Minimum"
msgstr "最小値"

#: ../../sources/guide/inputs.rst:294
msgid "Maximum"
msgstr "最大値"

#: ../../sources/guide/inputs.rst:294
msgid "Default"
msgstr "デフォルト値"

#: ../../sources/guide/inputs.rst:296
msgid "on_joy_axis"
msgstr "on_joy_axis"

#: ../../sources/guide/inputs.rst:296
msgid "-32767"
msgstr "-32767"

#: ../../sources/guide/inputs.rst:296
msgid "32767"
msgstr "32767"

#: ../../sources/guide/inputs.rst:296
msgid "0"
msgstr "0"

#: ../../sources/guide/inputs.rst:298
msgid "on_joy_hat"
msgstr "on_joy_hat"

#: ../../sources/guide/inputs.rst:298
msgid "(-1, -1)"
msgstr "(-1, -1)"

#: ../../sources/guide/inputs.rst:298
msgid "(1, 1)"
msgstr "(1, 1)"

#: ../../sources/guide/inputs.rst:298
msgid "(0, 0)"
msgstr "(0, 0)"

#: ../../sources/guide/inputs.rst:300
msgid "on_joy_ball"
msgstr "on_joy_ball"

#: ../../sources/guide/inputs.rst:300
msgid "Unknown"
msgstr "Unknown"

#: ../../sources/guide/inputs.rst:303
msgid ""
"Button events, on the other hand represent basically only a state of each"
" button i.e. `up` and `down`, therefore no such values are present."
msgstr "一方、ボタン・イベントは基本的に各ボタンの状態、つまり `up` と `down` のみを表すため、 のような数値は存在しません。"

#: ../../sources/guide/inputs.rst:306
msgid "on_joy_button_up"
msgstr "on_joy_button_up"

#: ../../sources/guide/inputs.rst:307
msgid "on_joy_button_down"
msgstr "on_joy_button_down"

#: ../../sources/guide/inputs.rst:310
msgid "Joystick event basics"
msgstr "Joystick event basics"

#: ../../sources/guide/inputs.rst:316
msgid ""
"Unlike touch events, joystick events are dispatched directly to the "
"Window, which means there's only a single value passed for e.g. a "
"specified axis, not multiple ones. This makes things harder if you want "
"to separate input to different widgets, yet not impossible. You can use "
"|dropexpl|_ as an inspiration."
msgstr "タッチ・イベントとは異なり、 ジョイスティック・イベントはウィンドウに直接発送(dispatch)されます。 つまり、 たとえば複数の軸ではなく、 指定の軸の 1 つの値のみが渡されます。 これは、 異なるウィジェットへの入力を分離したい場合に困難になりますが、 不可能ではありません。 |dropexpl|_ は上手い思いつきの一つです。"

#: ../../sources/guide/inputs.rst:322
msgid ""
"To get a joystick event, you first need to bind some function to the "
"Window joystick event like this::"
msgstr "ジョイスティック・イベントを取得するには、 まず以下のように関数を Window ジョイスティック・イベントに結び付ける(bind)する必要があります::"

#: ../../sources/guide/inputs.rst:327
msgid ""
"Then you need to fetch the parameters specified in "
":class:`~kivy.core.window.Window` for each event you use, for example::"
msgstr "次に、 あなたが使用するイベントごとに :class:`~kivy.core.window.Window` で指定されたパラメータを取得する必要があります。 例::"

#: ../../sources/guide/inputs.rst:333
msgid ""
"A variable `stickid` is an id of a controller that sent the value, "
"`axisid` is an id of an axis to which the value belongs."
msgstr "変数 `stickid` は値を送信したコントローラの ID、 `axisid`  は値が属する軸の ID です。"

#: ../../sources/guide/inputs.rst:337
msgid "Joystick input"
msgstr "Joystick input"

#: ../../sources/guide/inputs.rst:339
msgid ""
"Kivy should be able to fetch input from any device specified as "
"`gamepad`, `joystick` or basically any other type of game controller "
"recognized by the SDL2 provider. To make things easier, here are layouts "
"of some common controllers together with ids for each part."
msgstr "Kivy は、 `gamepad` または  `joystick` または基本的に SDL2 プロバイダーによって認識されるその他のタイプのゲーム・コントローラーとして指定された任意のデバイスから入力を取得できる必要があります。 簡単にするために、 一般的なコントローラーと各パーツの ID のレイアウトを以下に示します。"

#: ../../sources/guide/inputs.rst:345
msgid "Xbox 360"
msgstr "Xbox 360"

#: ../../sources/guide/inputs.rst:347
msgid "xbox_ctr"
msgstr "xbox_ctr"

#: ../../sources/guide/inputs.rst:360
msgid "|xbox_ctr|"
msgstr "|xbox_ctr|"

#: ../../sources/guide/inputs.rst:351
msgid "#"
msgstr "#"

#: ../../sources/guide/inputs.rst:351
msgid "ID"
msgstr "ID"

#: ../../sources/guide/inputs.rst:353
msgid "1"
msgstr "1"

#: ../../sources/guide/inputs.rst:353
msgid "axis 1"
msgstr "axis 1"

#: ../../sources/guide/inputs.rst:353
msgid "2"
msgstr "2"

#: ../../sources/guide/inputs.rst:353
msgid "axis 0"
msgstr "axis 0"

#: ../../sources/guide/inputs.rst:355
msgid "3"
msgstr "3"

#: ../../sources/guide/inputs.rst:355
msgid "hat Y"
msgstr "hat Y"

#: ../../sources/guide/inputs.rst:355
msgid "4"
msgstr "4"

#: ../../sources/guide/inputs.rst:355
msgid "hat X"
msgstr "hat X"

#: ../../sources/guide/inputs.rst:357
msgid "5"
msgstr "5"

#: ../../sources/guide/inputs.rst:357
msgid "axis 4"
msgstr "axis 4"

#: ../../sources/guide/inputs.rst:357
msgid "6"
msgstr "6"

#: ../../sources/guide/inputs.rst:357
msgid "axis 3"
msgstr "axis 3"

#: ../../sources/guide/inputs.rst:359
msgid "7"
msgstr "7"

#: ../../sources/guide/inputs.rst:359
msgid "axis 2"
msgstr "axis 2"

#: ../../sources/guide/inputs.rst:359
msgid "8"
msgstr "8"

#: ../../sources/guide/inputs.rst:359
msgid "axis 5"
msgstr "axis 5"

#: ../../sources/guide/inputs.rst:361
msgid "9"
msgstr "9"

#: ../../sources/guide/inputs.rst:361
msgid "button 4"
msgstr "button 4"

#: ../../sources/guide/inputs.rst:361
msgid "10"
msgstr "10"

#: ../../sources/guide/inputs.rst:361
msgid "button 5"
msgstr "button 5"

#: ../../sources/guide/inputs.rst:363
msgid "X"
msgstr "X"

#: ../../sources/guide/inputs.rst:363
msgid "button 2"
msgstr "button 2"

#: ../../sources/guide/inputs.rst:363
msgid "Y"
msgstr "Y"

#: ../../sources/guide/inputs.rst:363
msgid "button 3"
msgstr "button 3"

#: ../../sources/guide/inputs.rst:365
msgid "A"
msgstr "A"

#: ../../sources/guide/inputs.rst:365
msgid "button 0"
msgstr "button 0"

#: ../../sources/guide/inputs.rst:365
msgid "B"
msgstr "B"

#: ../../sources/guide/inputs.rst:365
msgid "button 1"
msgstr "button 1"

#: ../../sources/guide/inputs.rst:367
msgid "back"
msgstr "back"

#: ../../sources/guide/inputs.rst:367
msgid "button 6"
msgstr "button 6"

#: ../../sources/guide/inputs.rst:367
msgid "start"
msgstr "start"

#: ../../sources/guide/inputs.rst:367
msgid "button 7"
msgstr "button 7"

#: ../../sources/guide/inputs.rst:369
msgid "center"
msgstr "center"

#: ../../sources/guide/inputs.rst:369
msgid "button 10"
msgstr "button 10"

#: ../../sources/guide/inputs.rst:373
msgid "Joystick debugging"
msgstr "Joystick debugging"

#: ../../sources/guide/inputs.rst:378
msgid ""
"Mostly you'd want to debug your application with multiple controllers, or"
" test it against _other_ types of controllers (e.g. different brands). As"
" an alternative you might want to use some of the available controller "
"emulators, such as |vjoy|_."
msgstr "多くの場合、 あなたはアプリケーションを複数のコントローラでデバッグしたり、(異なるブランドなど)「他の」タイプのコントローラに対してテストしたりしたいと思うでしょう。 あなたは代替手段として、 |vjoy|_ などの既存のコントローラ・エミュレータを使用することもできます。"

