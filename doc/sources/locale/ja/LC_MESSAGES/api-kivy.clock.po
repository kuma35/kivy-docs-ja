# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Kivy 2.2.0.dev0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-12 08:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../sources/api-kivy.clock.rst:3
msgid "Clock object"
msgstr ""

#: kivy.clock:2 of
msgid ""
"The :class:`Clock` object allows you to schedule a function call in the "
"future; once or repeatedly at specified intervals. You can get the time "
"elapsed between the scheduling and the calling of the callback via the "
"`dt` argument::"
msgstr ""

#: kivy.clock:22 of
msgid ""
"If the callback returns False, the schedule will be canceled and won't "
"repeat."
msgstr ""

#: kivy.clock:25 of
msgid ""
"If you want to schedule a function to call with default arguments, you "
"can use the `functools.partial "
"<http://docs.python.org/library/functools.html#functools.partial>`_ "
"python module::"
msgstr ""

#: kivy.clock:37 of
msgid ""
"Conversely, if you want to schedule a function that doesn't accept the dt"
" argument, you can use a `lambda "
"<http://docs.python.org/2/reference/expressions.html#lambda>`_ expression"
" to write a short function that does accept dt. For Example::"
msgstr ""

#: kivy.clock:49 of
msgid ""
"You cannot unschedule an anonymous function unless you keep a reference "
"to it. It's better to add \\*args to your function definition so that it "
"can be called with an arbitrary number of parameters."
msgstr ""

#: kivy.clock:56 of
msgid ""
"The class method callback is weak-referenced: you are responsible for "
"keeping a reference to your original object/callback. If you don't keep a"
" reference, the ClockBase will never execute your callback. For example::"
msgstr ""

#: kivy.clock:83 of
msgid "Schedule before frame"
msgstr ""

#: kivy.clock:87 of
msgid ""
"Sometimes you need to schedule a callback BEFORE the next frame. Starting"
" from 1.0.5, you can use a timeout of -1::"
msgstr ""

#: kivy.clock:93 of
msgid ""
"The Clock will execute all the callbacks with a timeout of -1 before the "
"next frame even if you add a new callback with -1 from a running "
"callback. However, :class:`Clock` has an iteration limit for these "
"callbacks: it defaults to 10."
msgstr ""

#: kivy.clock:98 of
msgid ""
"If you schedule a callback that schedules a callback that schedules a ..."
" etc more than 10 times, it will leave the loop and send a warning to the"
" console, then continue after the next frame. This is implemented to "
"prevent bugs from hanging or crashing the application."
msgstr ""

#: kivy.clock:103 of
msgid ""
"If you need to increase the limit, set the :attr:`max_iteration` "
"property::"
msgstr ""

#: kivy.clock:111 of
msgid "Triggered Events"
msgstr ""

#: kivy.clock:115 of
msgid ""
":meth:`CyClockBase.create_trigger` is an advanced method way to defer a "
"callback. It functions exactly like :meth:`CyClockBase.schedule_once` and"
" :meth:`CyClockBase.schedule_interval` except that it doesn't immediately"
" schedule the callback. Instead, one schedules the callback using the "
":class:`ClockEvent` returned by it. This ensures that you can call the "
"event multiple times but it won't be scheduled more than once. This is "
"not the case with :meth:`CyClockBase.schedule_once`::"
msgstr ""

#: kivy.clock:137 of
msgid ""
"In addition, it is more convenient to create and bind to the triggered "
"event than using :meth:`CyClockBase.schedule_once` in a function::"
msgstr ""

#: kivy.clock:153 of
msgid "Even if x and y changes within one frame, the callback is only run once."
msgstr ""

#: kivy.clock:156 of
msgid "Unscheduling"
msgstr ""

#: kivy.clock:158 of
msgid ""
"An event scheduled with :meth:`CyClockBase.schedule_once`, "
":meth:`CyClockBase.schedule_interval`, or with "
":meth:`CyClockBase.create_trigger` and then triggered can be unscheduled "
"in multiple ways. E.g::"
msgstr ""

#: kivy.clock:185 of
msgid ""
"The best way to unschedule a callback is with :meth:`ClockEvent.cancel`. "
":meth:`CyClockBase.unschedule` is mainly an alias for that for that "
"function. However, if the original callback itself is passed to "
":meth:`CyClockBase.unschedule`, it'll unschedule all instances of that "
"callback (provided ``all`` is True, the default, otherwise only the first"
" match is removed)."
msgstr ""

#: kivy.clock:192 of
msgid ""
"Calling :meth:`CyClockBase.unschedule` on the original callback is highly"
" discouraged because it's significantly slower than when using the event."
msgstr ""

#: kivy.clock:196 of
msgid "Clock Lifecycle"
msgstr ""

#: kivy.clock:198 of
msgid ""
"Kivy's clock has a lifecycle. By default, scheduling a callback after the"
" Clock has ended will not raise an error, even though the callback may "
"never be called. That's because most callbacks are like services, e.g. "
"responding to a user button press - if the app is running the callbacks "
"need to service the app and respond to the input, but once the app has "
"stopped or is stopping, we can safely not process these events."
msgstr ""

#: kivy.clock:205 of
msgid ""
"Other events always need to be processed. E.g. another thread may request"
" a callback in kivy's thread and then process some result. If the event "
"is not processed in Kivy's thread because the app stopped, the second "
"thread may block forever hanging the application as it exits."
msgstr ""

#: kivy.clock:210 of
msgid ""
"Consequently, we provide a API "
"(:meth:`CyClockBase.create_lifecycle_aware_trigger`) for scheduling "
"callbacks that raise a :class:`ClockNotRunningError` if the clock has "
"stopped. If the scheduling succeeded it guarantees that one of its "
"callbacks will be called. I.e. the new "
":meth:`CyClockBase.create_lifecycle_aware_trigger` accepts an additional "
"``clock_ended_callback`` parameter. Normally, ``callback`` will be called"
" when the event is processed. But, if the clock is stopped before it can "
"be processed, if the application exited normally (and the app was "
"started) and the event wasn't canceled, and the callbacks are not garbage"
" collected, then ``clock_ended_callback`` will be called instead when the"
" clock is stopped."
msgstr ""

#: kivy.clock:221 of
msgid ""
"That is, given these conditions, if :class:`ClockNotRunningError` was not"
" raised when the event was scheduled, then one of these callbacks will be"
" called - either ``callback`` if the event executed normally, or "
"``clock_ended_callback`` if the clock is stopped while the event is "
"scheduled."
msgstr ""

#: kivy.clock:226 of
msgid ""
"By default, events can be scheduled before the clock is started because "
"it is assumed the clock will eventually be started when the app starts. "
"I.e. calling :meth:`CyClockBase.create_lifecycle_aware_trigger` before "
"the clock and application starts will succeed. But if the app never "
"actually starts, then neither of the callbacks may be executed."
msgstr ""

#: kivy.clock:232 of
msgid "The lifecycle was added in 2.0.0"
msgstr ""

#: kivy.clock:236 of
msgid "Exception Handling"
msgstr ""

#: kivy.clock:238 of
msgid ""
"Kivy provides a exception handling manager, "
":attr:`~kivy.base.ExceptionManager`, to handle its internal exceptions "
"including exceptions raised by clock callbacks, without crashing the "
"application. By default when an exception is raised, the app will crash. "
"But, if a handler is registered with the exception manager and the "
"handler handles the exception, the app will not crash and will continue "
"as normal.::"
msgstr ""

#: kivy.clock:255 of
msgid ""
"Then, all ValueError exceptions will be logged to the console and "
"ignored. Similarly, if a scheduled clock callback raises a ValueError, "
"other clock events will still be processed normally."
msgstr ""

#: kivy.clock:259 of
msgid ""
"If an event's callback raises an exception, before the exception handler "
"is executed, the callback is immediately canceled."
msgstr ""

#: kivy.clock:262 of
msgid ""
"It still is possible for the app to be corrupted if kivy itself is the "
"source of the exception. I.e. even with a handler that ignores exceptions"
" and doesn't crash, the app may be in a corrupted state if the error "
"originates from within Kivy itself. However, the exception handler can "
"help protect the app from crashing and can help protect against user "
"callbacks crashing the app."
msgstr ""

#: kivy.clock:268 of
msgid ""
"Prior to Kivy 2.0.0, an exception raised in a event's callback would "
"cause the clock to crash and subsequent events may or may not be "
"executed. Even if the exception was handled by an "
":class:`~kivy.base.ExceptionHandler`, there was no guarantee that some "
"scheduled events would not be skipped."
msgstr ""

#: kivy.clock:275 of
msgid ""
"From 2.0.0 onward, if a event's exception is handled by an "
":class:`~kivy.base.ExceptionHandler`, other events will be shielded from "
"the exception and will execute normally."
msgstr ""

#: kivy.clock:280 of
msgid "Scheduling from ``__del__``"
msgstr ""

#: kivy.clock:282 of
msgid ""
"It is not safe to schedule Clock events from a object's ``__del__`` or "
"``__dealloc__`` method. If you must schedule a Clock call from this "
"method, use :meth:`CyClockBase.schedule_del_safe` or "
":meth:`CyClockBase.schedule_lifecycle_aware_del_safe` instead."
msgstr ""

#: kivy.clock:288 of
msgid "Threading and Callback Order"
msgstr ""

#: kivy.clock:290 of
msgid ""
"Beginning with 1.10.0, all the events scheduled for the same frame, e.g. "
"all the events scheduled in the same frame with a ``timeout`` of ``0``, "
"well be executed in the order they were scheduled."
msgstr ""

#: kivy.clock:294 of
msgid ""
"Also, all the scheduling and canceling methods are fully thread safe and "
"can be safely used from external threads."
msgstr ""

#: kivy.clock:297 of
msgid ""
"As a a consequence, calling :meth:`CyClockBase.unschedule` with the "
"original callback is now significantly slower and highly discouraged. "
"Instead, the returned events should be used to cancel. As a tradeoff, all"
" the other methods are now significantly faster than before."
msgstr ""

#: kivy.clock:303 of
msgid "Advanced Clock Details"
msgstr ""

#: kivy.clock:305 of
msgid ""
"The following section goes into the internal kivy clock details as well "
"as the various clock options. It is meant only for advanced users."
msgstr ""

#: kivy.clock:308 of
msgid ""
"Fundamentally, the Kivy clock attempts to execute any scheduled callback "
"rhythmically as determined by the specified fps (frame per second, see "
"``maxfps`` in :mod:`~kivy.config`). That is, ideally, given e.g. a "
"desired fps of 30, the clock will execute the callbacks at intervals of 1"
" / 30 seconds, or every 33.33 ms. All the callbacks in a frame are given "
"the same timestamp, i.e. the ``dt`` passed to the callback are all the "
"same and it's the difference in time between the start of this and the "
"previous frame."
msgstr ""

#: kivy.clock:316 of
msgid ""
"Because of inherent indeterminism, the frames do not actually occur "
"exactly at intervals of the fps and ``dt`` may be under or over the "
"desired fps. Also, once the timeout is \"close enough\" to the desired "
"timeout, as determined internally, Kivy will execute the callback in the "
"current frame even when the \"actual time\" has not elapsed the "
"``timeout`` amount."
msgstr ""

#: kivy.clock:322 of
msgid ""
"Kivy offers now, since ``1.10.0``, multiple clocks with different "
"behaviors."
msgstr ""

#: kivy.clock:325 of
msgid "Default Clock"
msgstr ""

#: kivy.clock:327 of
msgid ""
"The default clock (``default``) behaves as described above. When a "
"callback with a timeout of zero or non-zero is scheduled, they are "
"executed at the frame that is near the timeout, which is a function of "
"the fps. So a timeout of zero would still result in a delay of one frame "
"or about 1 / fps, typically a bit less but sometimes more depending on "
"the CPU usage of the other events scheduled for that frame."
msgstr ""

#: kivy.clock:334 of
msgid ""
"In a test using a fps of 30, a callback with a timeout of 0, 0.001, and "
"0.05, resulted in a mean callback delay of 0.02487, 0.02488, and 0.05011 "
"seconds, respectively. When tested with a fps of 600 the delay for 0.05 "
"was similar, except the standard deviation was reduced resulting in "
"overall better accuracy."
msgstr ""

#: kivy.clock:340 of
msgid "Interruptible Clock"
msgstr ""

#: kivy.clock:342 of
msgid ""
"The default clock suffers from the quantization problem, as frames occur "
"only on intervals and any scheduled timeouts will not be able to occur "
"during an interval. For example, with the timeout of 0.05, while the mean"
" was 0.05011, its values ranged between 0.02548 - 0.07348 and a standard "
"deviation of 0.002. Also, there's the minimum timeout of about 0.02487."
msgstr ""

#: kivy.clock:348 of
msgid ""
"The interruptible clock (``interrupt``) will execute timeouts even during"
" a frame. So a timeout of zero will execute as quickly as possible and "
"similarly a non-zero timeout will be executed even during the interval."
msgstr ""

#: kivy.clock:352 of
msgid ""
"This clock, and all the clocks described after this have an option, "
":attr:`ClockBaseInterruptBehavior.interupt_next_only`. When True, any of "
"the behavior new behavior will only apply to the callbacks with a timeout"
" of zero. Non-zero timeouts will behave like in the default clock. E.g. "
"for this clock when True, only zero timeouts will execute during the the "
"interval."
msgstr ""

#: kivy.clock:358 of
msgid ""
"In a test using a fps of 30, a callback with a timeout of 0, 0.001, and "
"0.05, resulted in a mean callback delay of 0.00013, 0.00013, and 0.04120 "
"seconds, respectively when "
":attr:`ClockBaseInterruptBehavior.interupt_next_only` was False. Also, "
"compared to the default clock the standard deviation was reduced. When "
":attr:`ClockBaseInterruptBehavior.interupt_next_only` was True, the "
"values were 0.00010, 0.02414, and 0.05034, respectively."
msgstr ""

#: kivy.clock:366 of
msgid "Free Clock"
msgstr ""

#: kivy.clock:368 of
msgid ""
"The interruptible clock may not be ideal for all cases because all the "
"events are executed during the intervals and events are not executed "
"anymore rhythmically as multiples of the fps. For example, there may not "
"be any benefit for the graphics to update in a sub-interval, so the "
"additional accuracy wastes CPU."
msgstr ""

#: kivy.clock:374 of
msgid ""
"The Free clock (``free_all``) solves this by having ``Clock.xxx_free`` "
"versions of all the Clock scheduling methods. By free, we mean the event "
"is free from the fps because it's not fps limited. E.g. "
":meth:`CyClockBaseFree.create_trigger_free` corresponds to "
":meth:`CyClockBase.create_trigger`. Only when an event scheduled using "
"the ``Clock.xxx_free`` methods is present will the clock interrupt and "
"execute the events during the interval. So, if no ``free`` event is "
"present the clock behaves like the ``default`` clock, otherwise it "
"behaves like the ``interrupt`` clock."
msgstr ""

#: kivy.clock:384 of
msgid ""
"In a test using a fps of 30, a callback with a timeout of 0s, 0.001s, and"
" 0.05s, resulted in a mean callback delay of 0.00012s, 0.00017s, and "
"0.04121s seconds, respectively when it was a free event and 0.02403s, "
"0.02405s, and 0.04829s, respectively when it wasn't."
msgstr ""

#: kivy.clock:390 of
msgid "Free Only Clock"
msgstr ""

#: kivy.clock:392 of
msgid ""
"The Free clock executes all events when a free event was scheduled. This "
"results in normal events also being execute in the middle of the interval"
" when a free event is scheduled. For example, above, when a free event "
"was absent, a normal event with a 0.001s timeout was delayed for "
"0.02405s. However, if a free event happened to be also scheduled, the "
"normal event was only delayed 0.00014s, which may be undesirable."
msgstr ""

#: kivy.clock:399 of
msgid ""
"The Free only clock (``free_only``) solves it by only executing free "
"events during the interval and normal events are always executed like "
"with the default clock. For example, in the presence of a free event, a "
"normal event with a timeout of 0.001s still had a delay of 0.02406. So "
"this clock, treats free and normal events independently, with normal "
"events always being fps limited, but never the free events."
msgstr ""

#: kivy.clock:407 of
msgid "Summary"
msgstr ""

#: kivy.clock:409 of
msgid ""
"The kivy clock type to use can be set with the ``kivy_clock`` option the "
":mod:`~kivy.config`. If ``KIVY_CLOCK`` is present in the environment it "
"overwrites the config selection. Its possible values are as follows:"
msgstr ""

#: kivy.clock:413 of
msgid ""
"When ``kivy_clock`` is ``default``, the normal clock, :class:`ClockBase`,"
" which limits callbacks to the maxfps quantization - is used."
msgstr ""

#: kivy.clock:415 of
msgid ""
"When ``kivy_clock`` is ``interrupt``, a interruptible clock, "
":class:`ClockBaseInterrupt`, which doesn't limit any callbacks to the "
"maxfps - is used. Callbacks will be executed at any time."
msgstr ""

#: kivy.clock:418 of
msgid ""
"When ``kivy_clock`` is ``free_all``, a interruptible clock, "
":class:`ClockBaseFreeInterruptAll`, which doesn't limit any callbacks to "
"the maxfps in the presence of free events, but in their absence it limits"
" events to the fps quantization interval - is used."
msgstr ""

#: kivy.clock:422 of
msgid ""
"When ``kivy_clock`` is ``free_only``, a interruptible clock, "
":class:`ClockBaseFreeInterruptAll`, which treats free and normal events "
"independently; normal events are fps limited while free events are not - "
"is used."
msgstr ""

#: kivy.clock:428 of
msgid "Async clock support"
msgstr ""

#: kivy.clock:432 of
msgid ""
"Experimental async support has been added in 2.0.0. The Clock now has a "
":meth:`ClockBaseBehavior.async_tick` and "
":meth:`ClockBaseBehavior.async_idle` coroutine method which is used by "
"the kivy EventLoop when the kivy EventLoop is executed in a asynchronous "
"manner. When used, the kivy clock does not block while idling."
msgstr ""

#: kivy.clock:438 of
msgid ""
"The async library to use is selected with the `KIVY_EVENTLOOP` "
"environmental variable or by  calling "
":meth:`~kivy.clock.ClockBaseBehavior.init_async_lib` directly. The "
"library can be one of `\"asyncio\"` when the standard library `asyncio` "
"should be used, or `\"trio\"` if the trio library should be used. If not "
"set it defaults to `\"asyncio\"`."
msgstr ""

#: kivy.clock:444 of
msgid "See :mod:`~kivy.app` for example usage."
msgstr ""

#: ../../docstring kivy.clock.Clock:1 of
msgid "The kivy Clock instance. See module documentation for details."
msgstr ""

#: ../../<autodoc>:1
msgid ""
"Bases: :class:`kivy.clock.ClockBaseBehavior`, "
":class:`kivy._clock.CyClockBase`"
msgstr ""

#: kivy.clock.ClockBase:1 of
msgid "The ``default`` kivy clock. See module for details."
msgstr ""

#: kivy.clock.ClockBase.usleep:1 kivy.clock.ClockBaseBehavior.usleep:1
#: kivy.clock.ClockBaseInterruptBehavior.usleep:1 of
msgid "Sleeps for the number of microseconds."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`builtins.object`"
msgstr ""

#: kivy.clock.ClockBaseBehavior:1 of
msgid "The base of the kivy clock."
msgstr ""

#: ../../docstring kivy.clock.ClockBaseBehavior
#: kivy.clock.ClockBaseBehavior.init_async_lib
#: kivy.clock.ClockBaseInterruptBehavior.init_async_lib
#: kivy.clock.CyClockBase.unschedule of
msgid "parameters"
msgstr ""

#: kivy.clock.ClockBaseBehavior:13 of
msgid "`async_lib`: string"
msgstr ""

#: kivy.clock.ClockBaseBehavior:6
#: kivy.clock.ClockBaseBehavior.init_async_lib:10
#: kivy.clock.ClockBaseInterruptBehavior.init_async_lib:10 of
msgid ""
"The async library to use when the clock is run asynchronously. Can be one"
" of, `\"asyncio\"` when the standard library asyncio should be used, or "
"`\"trio\"` if the trio library should be used."
msgstr ""

#: kivy.clock.ClockBaseBehavior:10 of
msgid ""
"It defaults to `'asyncio'` or the value in the environmental variable "
"`KIVY_EVENTLOOP` if set. :meth:`init_async_lib` can also be called "
"directly to set the library."
msgstr ""

#: ../../docstring kivy.clock.ClockBaseBehavior.MIN_SLEEP:1 of
msgid ""
"The minimum time to sleep. If the remaining time is less than this, the "
"event loop will continue."
msgstr ""

#: kivy.clock.ClockBaseBehavior.async_idle:1
#: kivy.clock.ClockBaseFreeInterruptOnly.async_idle:1
#: kivy.clock.ClockBaseInterruptBehavior.async_idle:1 of
msgid "(internal) async version of :meth:`idle`."
msgstr ""

#: kivy.clock.ClockBaseBehavior.async_tick:1 of
msgid "async version of :meth:`tick`."
msgstr ""

#: kivy.clock.ClockBaseBehavior.frames:1 of
msgid ""
"Number of internal frames (not necessarily drawn) from the start of the "
"clock."
msgstr ""

#: kivy.clock.ClockBaseBehavior.frames_displayed:1 of
msgid "Number of displayed frames from the start of the clock."
msgstr ""

#: kivy.clock.ClockBaseBehavior.frametime:1 of
msgid "Time spent between the last frame and the current frame (in seconds)."
msgstr ""

#: kivy.clock.ClockBaseBehavior.get_boottime:1 of
msgid "Get the time in seconds from the application start."
msgstr ""

#: kivy.clock.ClockBaseBehavior.get_fps:1 of
msgid "Get the current average FPS calculated by the clock."
msgstr ""

#: kivy.clock.ClockBaseBehavior.get_rfps:1 of
msgid ""
"Get the current \"real\" FPS calculated by the clock. This counter "
"reflects the real framerate displayed on the screen."
msgstr ""

#: kivy.clock.ClockBaseBehavior.get_rfps:4 of
msgid ""
"In contrast to get_fps(), this function returns a counter of the number "
"of frames, not the average of frames per second."
msgstr ""

#: kivy.clock.ClockBaseBehavior.get_time:1 of
msgid "Get the last tick made by the clock."
msgstr ""

#: kivy.clock.ClockBaseBehavior.idle:1
#: kivy.clock.ClockBaseFreeInterruptOnly.idle:1
#: kivy.clock.ClockBaseInterruptBehavior.idle:1 of
msgid "(internal) waits here until the next frame."
msgstr ""

#: kivy.clock.ClockBaseBehavior.init_async_lib:1
#: kivy.clock.ClockBaseInterruptBehavior.init_async_lib:1 of
msgid ""
"Manually sets the async library to use internally, when running in a "
"asynchronous manner."
msgstr ""

#: kivy.clock.ClockBaseBehavior.init_async_lib:4
#: kivy.clock.ClockBaseInterruptBehavior.init_async_lib:4 of
msgid ""
"This can be called anytime before the kivy event loop has started, but "
"not once the kivy App is running."
msgstr ""

#: kivy.clock.ClockBaseBehavior.init_async_lib:11
#: kivy.clock.ClockBaseInterruptBehavior.init_async_lib:11 of
msgid "`lib`: string"
msgstr ""

#: kivy.clock.ClockBaseBehavior.post_idle:1 of
msgid "Called after :meth:`idle` by :meth:`tick`."
msgstr ""

#: kivy.clock.ClockBaseBehavior.pre_idle:1 of
msgid "Called before :meth:`idle` by :meth:`tick`."
msgstr ""

#: kivy.clock.ClockBaseBehavior.tick:1 of
msgid ""
"Advance the clock to the next step. Must be called every frame. The "
"default clock has a tick() function called by the core Kivy framework."
msgstr ""

#: kivy.clock.ClockBaseBehavior.tick_draw:1 of
msgid "Tick the drawing counter."
msgstr ""

#: kivy.clock.ClockBaseBehavior.time:1 of
msgid "Proxy method for :func:`~kivy.compat.clock`."
msgstr ""

#: ../../<autodoc>:1
msgid ""
"Bases: :class:`kivy.clock.ClockBaseInterruptFreeBehavior`, "
":class:`kivy._clock.CyClockBaseFree`"
msgstr ""

#: kivy.clock.ClockBaseFreeInterruptAll:1 of
msgid "The ``free_all`` kivy clock. See module for details."
msgstr ""

#: kivy.clock.ClockBaseFreeInterruptOnly:1 of
msgid "The ``free_only`` kivy clock. See module for details."
msgstr ""

#: ../../<autodoc>:1
msgid ""
"Bases: :class:`kivy.clock.ClockBaseInterruptBehavior`, "
":class:`kivy._clock.CyClockBase`"
msgstr ""

#: kivy.clock.ClockBaseInterrupt:1 of
msgid "The ``interrupt`` kivy clock. See module for details."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy.clock.ClockBaseBehavior`"
msgstr ""

#: kivy.clock.ClockBaseInterruptBehavior:1 of
msgid "A kivy clock which can be interrupted during a frame to execute events."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy.clock.ClockBaseInterruptBehavior`"
msgstr ""

#: kivy.clock.ClockBaseInterruptFreeBehavior:1 of
msgid ""
"A base class for the clock that interrupts the sleep interval for free "
"events."
msgstr ""

#: ../../docstring kivy._clock.ClockEvent:1 of
msgid ""
"This class is never created by the user; instead, kivy creates and "
"returns an instance of this class when scheduling a callback."
msgstr ""

#: ../../docstring kivy._clock.ClockEvent:4 of
msgid ""
"An event can be triggered (scheduled) by calling it. If it's already "
"scheduled, nothing will happen, otherwise it'll be scheduled. E.g.::"
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.callback:1 of
msgid "callback: object"
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.cancel:1 of
msgid ""
"Cancels the callback if it was scheduled to be called. If not scheduled, "
"nothing happens."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.cid:1 of
msgid "cid: object"
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.clock:1 of
msgid ""
"clock: kivy._clock.CyClockBase The :class:`CyClockBase` instance "
"associated with the event."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.clock_ended_callback:1 of
msgid ""
"clock_ended_callback: object A Optional callback for this event, which if"
" provided is called by the clock"
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.clock_ended_callback:3 of
msgid "when the clock is stopped and the event was not ticked."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.get_callback:1 of
msgid ""
"Returns the callback associated with the event. Callbacks get stored with"
" a indirect ref so that it doesn't keep objects alive. If the callback is"
" dead, None is returned."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.get_clock_ended_callback:1 of
msgid ""
"Returns the clock_ended_callback associated with the event. Callbacks get"
" stored with a indirect ref so that it doesn't keep objects alive. If the"
" callback is dead or wasn't provided, None is returned."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.is_triggered:1 of
msgid ""
"Returns whether the event is scheduled to have its callback executed by "
"the kivy thread."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.loop:1 of
msgid "loop: 'int' Whether this event repeats at intervals of :attr:`timeout`."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.next:1 of
msgid ""
"next: kivy._clock.ClockEvent The next :class:`ClockEvent` in order they "
"were scheduled."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.prev:1 of
msgid ""
"prev: kivy._clock.ClockEvent The previous :class:`ClockEvent` in order "
"they were scheduled."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.release:1 of
msgid "(internal method) Converts the callback into a indirect ref."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.release_ref:1 of
msgid ""
"release_ref: 'int' If True, the event should never release the reference "
"to the callbacks."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.release_ref:3 of
msgid "If False, a weakref may be created instead."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.tick:1 of
msgid "(internal method) Processes the event for the kivy thread."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.timeout:1 of
msgid ""
"timeout: 'double' The duration after scheduling when the callback should "
"be executed."
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.weak_callback:1 of
msgid "weak_callback: object"
msgstr ""

#: ../../docstring kivy.clock.ClockEvent.weak_clock_ended_callback:1 of
msgid "weak_clock_ended_callback: object"
msgstr ""

#: ../../docstring kivy._clock.ClockNotRunningError:1 of
msgid "Bases: :py:class:`RuntimeError`"
msgstr ""

#: ../../docstring kivy._clock.ClockNotRunningError:1 of
msgid ""
"Raised by the kivy Clock when scheduling an event if the Kivy Clock has "
"already finished (:class:`~CyClockBase.stop_clock` was called)."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.clock_resolution:1 of
msgid ""
"clock_resolution: 'double' If the remaining time until the event timeout "
"is less than :attr:`clock_resolution`,"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.clock_resolution:3 of
msgid "the clock will execute the callback even if it hasn't exactly timed out."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.clock_resolution:5 of
msgid ""
"If -1, the default, the resolution will be computed from config's "
"``maxfps``. Otherwise, the provided value is used. Defaults to -1."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:1 of
msgid ""
"Create a Trigger event similarly to :meth:`create_trigger`, but the event"
" is sensitive to the clock's state."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:4 of
msgid ""
"If this event is triggered after the clock has stopped "
"(:meth:`stop_clock`), then a :class:`ClockNotRunningError` will be "
"raised. If the error is not raised, then either ``callback`` or "
"``clock_ended_callback`` will be called. ``callback`` will be called when"
" the event is normally executed. If the clock is stopped before it can be"
" executed, provided the app exited normally without crashing and the "
"event wasn't manually canceled, and the callbacks are not garbage "
"collected then ``clock_ended_callback`` will be called instead when the "
"clock is stopped."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger
#: kivy.clock.CyClockBase.create_trigger
#: kivy.clock.CyClockBase.handle_exception
#: kivy.clock.CyClockBase.schedule_del_safe
#: kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe of
msgid "Parameters"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:16
#: kivy.clock.CyClockBase.create_trigger:13 of
msgid "`callback`: callable"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:16
#: kivy.clock.CyClockBase.create_trigger:13 of
msgid ""
"The callback to execute from kivy. It takes a single parameter - the "
"current elapsed kivy time."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:23
#: kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:23 of
msgid "`clock_ended_callback`: callable"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:19 of
msgid ""
"A callback that will be called if the clock is stopped while the event is"
" still scheduled to be called. The callback takes a single parameter - "
"the event object. When the event is successfully scheduled, if the app "
"exited normally and the event wasn't canceled, and the callbacks are not "
"garbage collected - it is guaranteed that either ``callback`` or "
"``clock_ended_callback`` would have been called."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:25
#: kivy.clock.CyClockBase.create_trigger:15 of
msgid "`timeout`: float"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:26
#: kivy.clock.CyClockBase.create_trigger:16 of
msgid "How long to wait before calling the callback."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:28
#: kivy.clock.CyClockBase.create_trigger:18 of
msgid "`interval`: bool"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:28
#: kivy.clock.CyClockBase.create_trigger:18 of
msgid ""
"Whether the callback should be called once (False) or repeatedly with a "
"period of ``timeout`` (True) like :meth:`schedule_interval`."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:35
#: kivy.clock.CyClockBase.create_trigger:25 of
msgid "`release_ref`: bool"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:31 of
msgid ""
"If True, the default, then if ``callback`` or ``clock_ended_callback`` is"
" a class method and the object has no references to it, then the object "
"may be garbage collected and the callbacks won't be called. If False, the"
" clock keeps a reference to the object preventing it from being garbage "
"collected - so it will be called."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger
#: kivy.clock.CyClockBase.create_trigger
#: kivy.clock.CyClockBase.schedule_interval
#: kivy.clock.CyClockBase.schedule_once of
msgid "Returns"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_lifecycle_aware_trigger:37
#: kivy.clock.CyClockBase.create_trigger:27 of
msgid ""
"A :class:`ClockEvent` instance. To schedule the callback of this "
"instance, you can call it."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_trigger:1 of
msgid ""
"Create a Trigger event. It is thread safe but not ``__del__`` or "
"``__dealloc__`` safe (see :meth:`schedule_del_safe`). Check module "
"documentation for more information."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_trigger:5 of
msgid ""
"To cancel the event before it is executed, call :meth:`ClockEvent.cancel`"
" on the returned event. To schedule it again, simply call the event "
"(``event()``) and it'll be safely rescheduled if it isn't already "
"scheduled."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_trigger:21 of
msgid ""
"If True, the default, then if ``callback`` is a class method and the "
"object has no references to it, then the object may be garbage collected "
"and the callbacks won't be called. If False, the clock keeps a reference "
"to the object preventing it from being garbage collected - so it will be "
"called."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_trigger:36 of
msgid "``interval`` has been added."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.create_trigger:40 of
msgid "``release_ref`` has been added."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.get_before_frame_events:1 of
msgid ""
"Returns the list of :class:`ClockEvent` instances that are scheduled to "
"be called before the next frame (``-1`` timeout)."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.get_events:1 of
msgid "Returns the list of :class:`ClockEvent` instances currently scheduled."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.get_min_timeout:1 of
msgid ""
"Returns the remaining time since the start of the current frame for the "
"event with the smallest timeout."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.get_resolution:1 of
msgid ""
"Returns the minimum resolution the clock has. It's a function of "
":attr:`clock_resolution` and ``maxfps`` provided at the config."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.handle_exception:1 of
msgid "Provides an opportunity to handle an event's exception."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.handle_exception:3 of
msgid ""
"If desired, the exception is handled, otherwise it should be raised "
"again. By default it is raised again."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.handle_exception:6 of
msgid "The exception to be handled."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.has_ended:1 of
msgid "has_ended: 'int'"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.has_started:1 of
msgid "has_started: 'int'"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.max_iteration:1 of
msgid ""
"max_iteration: 'int' The maximum number of callback iterations at the end"
" of the frame, before the next"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.max_iteration:3 of
msgid "frame. If more iterations occur, a warning is issued."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.on_schedule:1 of
msgid ""
"Function that is called internally every time an event is triggered for "
"this clock. It takes the event as a parameter."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.on_schedule:4 of
msgid ""
"The order of ``on_schedule`` calls are not guaranteed to be in the same "
"order that the events are scheduled. Similarly, it is possible that the "
"event being scheduled was canceled before this is called on the event. "
"That's because :meth:`on_schedule` may be called from different threads."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_del_safe:1 of
msgid ""
"Schedule a callback that is thread safe and ``__del__`` or "
"``__dealloc__`` safe."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_del_safe:4 of
msgid ""
"It's unsafe to call various kinds of code from ``__del__`` or "
"``__dealloc__`` methods because they can be executed at any time. Most "
"Kivy's Clock methods are unsafe to call the Clock from these methods. "
"Instead, use this method, which is thread safe and ``__del__`` or "
"``__dealloc__`` safe, to schedule the callback in the kivy thread. It'll "
"be executed in order after the normal events are processed."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_del_safe:15
#: kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:16 of
msgid "`callback`: Callable"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_del_safe:14
#: kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:16 of
msgid ""
"The callback the execute from kivy. It takes no parameters and cannot be "
"canceled."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_interval:1 of
msgid ""
"Schedule an event to be called every <timeout> seconds. See "
":meth:`create_trigger` for advanced scheduling and more details."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_interval:4
#: kivy.clock.CyClockBase.schedule_once:5 of
msgid ""
"To cancel the event before it is executed, call :meth:`ClockEvent.cancel`"
" on the returned event. If the callback is a class method, a weakref to "
"the object is created and it may be garbage collected if there's no other"
" reference to the object."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_interval:9
#: kivy.clock.CyClockBase.schedule_once:10 of
msgid ""
"A :class:`ClockEvent` instance. As opposed to :meth:`create_trigger` "
"which only creates the trigger event, this method also schedules it."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:1
#: of
msgid ""
"Schedule a callback that is thread safe and ``__del__`` or "
"``__dealloc__`` safe similarly to :meth:`schedule_del_safe`, but the "
"callback is sensitive to the clock's state."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:5
#: of
msgid ""
"If this event is triggered after the clock has stopped "
"(:meth:`stop_clock`), then a :class:`ClockNotRunningError` will be "
"raised. If the error is not raised, then either ``callback`` or "
"``clock_ended_callback`` will be called. ``callback`` will be called when"
" the callback is normally executed. If the clock is stopped before it can"
" be executed, provided the app exited normally without crashing then "
"``clock_ended_callback`` will be called instead when the clock is "
"stopped."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:19
#: of
msgid ""
"A callback that will be called if the clock is stopped while the callback"
" is still scheduled to be called. The callback takes a single parameter -"
" the callback. If the app exited normally, it is guaranteed that either "
"``callback`` or ``clock_ended_callback`` would have been called."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_once:1 of
msgid ""
"Schedule an event in <timeout> seconds. If <timeout> is unspecified or 0,"
" the callback will be called after the next frame is rendered. See "
":meth:`create_trigger` for advanced scheduling and more details."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.schedule_once:16 of
msgid ""
"If the timeout is -1, the callback will be called before the next frame "
"(at :meth:`tick_draw`)."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.start_clock:1 of
msgid "Must be called to start the clock."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.start_clock:3 of
msgid "Once :meth:`stop_clock` is called, it cannot be started again."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.stop_clock:1 of
msgid "Stops the clock and cleans up."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.stop_clock:3 of
msgid "This must be called to process the lifecycle_aware callbacks etc."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.unschedule:1 of
msgid "Remove a previously scheduled event."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.unschedule:3 of
msgid ""
"An :class:`ClockEvent` can also be canceled directly by calling "
":meth:`ClockEvent.cancel`."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.unschedule:19 of
msgid "`callback`: :class:`ClockEvent` or a callable."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.unschedule:9 of
msgid ""
"If it's a :class:`ClockEvent` instance, then the callback associated with"
" this event will be canceled if it is scheduled."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.unschedule:13 of
msgid ""
"If it's a callable, then the callable will be unscheduled if it was "
"scheduled."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.unschedule:18 of
msgid ""
"Passing the callback function rather than the returned "
":class:`ClockEvent` will result in a significantly slower unscheduling."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.unschedule:24 of
msgid "`all`: bool"
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.unschedule:22 of
msgid ""
"If True and if `callback` is a callable, all instances of this callable "
"will be unscheduled (i.e. if this callable was scheduled multiple times)."
" Defaults to `True`."
msgstr ""

#: ../../docstring kivy.clock.CyClockBase.unschedule:26 of
msgid "The all parameter was added. Before, it behaved as if `all` was `True`."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy._clock.CyClockBase`"
msgstr ""

#: ../../docstring kivy._clock.CyClockBaseFree:1 of
msgid ""
"A clock class that supports scheduling free events in addition to normal "
"events."
msgstr ""

#: ../../docstring kivy._clock.CyClockBaseFree:4 of
msgid ""
"Each of the :meth:`~CyClockBase.create_trigger`, "
":meth:`~CyClockBase.schedule_once`, and "
":meth:`~CyClockBase.schedule_interval` methods, which create a normal "
"event, have a corresponding method for creating a free event."
msgstr ""

#: ../../docstring
#: kivy.clock.CyClockBaseFree.create_lifecycle_aware_trigger_free:1 of
msgid ""
"Similar to :meth:`~CyClockBase.create_lifecycle_aware_trigger`, but "
"instead creates a free event."
msgstr ""

#: ../../docstring kivy.clock.CyClockBaseFree.create_trigger_free:1 of
msgid ""
"Similar to :meth:`~CyClockBase.create_trigger`, but instead creates a "
"free event."
msgstr ""

#: ../../docstring kivy.clock.CyClockBaseFree.get_min_free_timeout:1 of
msgid ""
"Returns the remaining time since the start of the current frame for the "
"*free* event with the smallest timeout."
msgstr ""

#: ../../docstring kivy.clock.CyClockBaseFree.schedule_interval_free:1 of
msgid ""
"Similar to :meth:`~CyClockBase.schedule_interval`, but instead creates a "
"free event."
msgstr ""

#: ../../docstring kivy.clock.CyClockBaseFree.schedule_once_free:1 of
msgid ""
"Similar to :meth:`~CyClockBase.schedule_once`, but instead creates a free"
" event."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy._clock.ClockEvent`"
msgstr ""

#: ../../docstring kivy._clock.FreeClockEvent:1 of
msgid ""
":class:`CyClockBaseFree`. It stores whether the event was scheduled as a "
"free event."
msgstr ""

#: ../../docstring kivy.clock.FreeClockEvent.free:1 of
msgid "free: 'int' Whether this event was scheduled as a free event."
msgstr ""

#: kivy.clock.mainthread:1 of
msgid ""
"Decorator that will schedule the call of the function for the next "
"available frame in the mainthread. It can be useful when you use "
":class:`~kivy.network.urlrequest.UrlRequest` or when you do Thread "
"programming: you cannot do any OpenGL-related work in a thread."
msgstr ""

#: kivy.clock.mainthread:6 of
msgid ""
"Please note that this method will return directly and no result can be "
"returned::"
msgstr ""

#: kivy.clock.triggered:1 of
msgid ""
"Decorator that will trigger the call of the function at the specified "
"timeout, through the method :meth:`CyClockBase.create_trigger`. "
"Subsequent calls to the decorated function (while the timeout is active) "
"are ignored."
msgstr ""

#: kivy.clock.triggered:5 of
msgid ""
"It can be helpful when an expensive function (i.e. call to a server) can "
"be triggered by different methods. Setting a proper timeout will delay "
"the calling and only one of them will be triggered."
msgstr ""

#: kivy.clock.triggered:9 of
msgid "@triggered(timeout, interval=False) def callback(id):"
msgstr ""

#: kivy.clock.triggered:11 of
#, python-format
msgid "print('The callback has been called with id=%d' % id)"
msgstr ""

#: kivy.clock.triggered:13 of
msgid ">> callback(id=1) >> callback(id=2) The callback has been called with id=2"
msgstr ""

#: kivy.clock.triggered:17 of
msgid "The decorated callback can also be unscheduled using:"
msgstr ""

#: kivy.clock.triggered:19 of
msgid ">> callback.cancel()"
msgstr ""

