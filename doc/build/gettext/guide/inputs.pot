# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Kivy 2.2.0.dev0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-12 08:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/inputs.rst:2
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
msgid "Input architecture"
msgstr ""

#: ../../sources/guide/inputs.rst:7
msgid "Kivy is able to handle most types of input: mouse, touchscreen, accelerometer, gyroscope, etc. It handles the native multitouch protocols on the following platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B and Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
msgid "The global architecture can be viewed as::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
msgid "The class of all input events is the :class:`~kivy.input.motionevent.MotionEvent`. It generates 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
msgid "Touch events: a motion event that contains at least an X and Y position. All the touch events are dispatched across the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
msgid "No-touch events: all the rest. For example, the accelerometer is a continuous event, without position. It never starts or stops. These events are not dispatched across the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
msgid "A Motion event is generated by an :mod:`Input Provider <kivy.input.providers>`. An Input Provider is responsible for reading the input event from the operating system, the network or even from another application. Several input providers exist, such as:"
msgstr ""

#: ../../sources/guide/inputs.rst:31
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create a UDP server and listen for TUIO/OSC messages."
msgstr ""

#: ../../sources/guide/inputs.rst:33
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending it to Kivy."
msgstr ""

#: ../../sources/guide/inputs.rst:35
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: In Linux, iterate over all the hardware connected to the computer, and attaches a multitouch input provider for each multitouch device found."
msgstr ""

#: ../../sources/guide/inputs.rst:38
msgid "and much more!"
msgstr ""

#: ../../sources/guide/inputs.rst:40
msgid "When you write an application, you don't need to create an input provider. Kivy tries to automatically detect available hardware. However, if you want to support custom hardware, you will need to configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:44
msgid "Before the newly-created Motion Event is passed to the user, Kivy applies post-processing to the input. Every motion event is analyzed to detect and correct faulty input, as well as make meaningful interpretations like:"
msgstr ""

#: ../../sources/guide/inputs.rst:48
msgid "Double/triple-tap detection, according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:49
msgid "Making events more accurate when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:50
msgid "Reducing the amount of generated events if the native touch hardware is sending events with nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:53
msgid "After processing, the motion event is dispatched to the Window. As explained previously, not all events are dispatched to the whole widget tree: the window filters them. For a given event:"
msgstr ""

#: ../../sources/guide/inputs.rst:57
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:59
msgid "if it's a touch event, the (x,y) position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:62
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:63
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:64
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:68
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:70
msgid "Depending on your hardware and the input providers used, more information may be made available to you. For example, a touch input has an (x,y) position, but might also have pressure information, blob size, an acceleration vector, etc."
msgstr ""

#: ../../sources/guide/inputs.rst:74
msgid "A profile is a string that indicates what features are available inside the motion event. Let's imagine that you are in an ``on_touch_move`` method::"
msgstr ""

#: ../../sources/guide/inputs.rst:81
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:87
msgid "Many people mix up the profile's name and the name of the corresponding property. Just because ``'angle'`` is in the available profile doesn't mean that the touch event object will have an ``angle`` property."
msgstr ""

#: ../../sources/guide/inputs.rst:91
msgid "For the ``'pos'`` profile, the properties ``pos``, ``x``, and ``y`` will be available. With the ``'angle'`` profile, the property ``a`` will be available. As we said, for touch events ``'pos'`` is a mandatory profile, but not ``'angle'``. You can extend your interaction by checking if the ``'angle'`` profile exists::"
msgstr ""

#: ../../sources/guide/inputs.rst:102
msgid "You can find a list of available profiles in the :mod:`~kivy.input.motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:106
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:108
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` where the property :attr:`~kivy.input.motionevent.MotionEvent.is_touch` evaluates to True. For all touch events, you automatically have the X and Y positions available, scaled to the Window width and height. In other words, all touch events have the ``'pos'`` profile."
msgstr ""

#: ../../sources/guide/inputs.rst:115
msgid "Touch event basics"
msgstr ""

#: ../../sources/guide/inputs.rst:117
msgid "By default, touch events are dispatched to all currently displayed widgets. This means widgets receive the touch event whether it occurs within their physical area or not."
msgstr ""

#: ../../sources/guide/inputs.rst:121
msgid "This can be counter intuitive if you have experience with other GUI toolkits. These typically divide the screen into geometric areas and only dispatch touch or mouse events to the widget if the coordinate lies within the widgets area."
msgstr ""

#: ../../sources/guide/inputs.rst:126
msgid "This requirement becomes very restrictive when working with touch input. Swipes, pinches and long presses may well originate from outside of the widget that wants to know about them and react to them."
msgstr ""

#: ../../sources/guide/inputs.rst:130
msgid "In order to provide the maximum flexibility, Kivy dispatches the events to all the widgets and lets them decide how to react to them. If you only want to respond to touch events inside the widget, you simply check::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
msgid "Coordinates"
msgstr ""

#: ../../sources/guide/inputs.rst:143
msgid "You must take care of matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets such as :class:`~kivy.uix.scatter.Scatter` have their own matrix transformation, meaning the touch must be multiplied by the scatter matrix to be able to correctly dispatch touch positions to the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:150
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:152
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:154
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:156
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:159
msgid "You must use one of them to scale coordinates correctly to the context. Let's look the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:182
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:184
msgid "If the touch has a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` can be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:196
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:198
msgid "A double tap is the action of tapping twice within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:210
msgid "Triple tap"
msgstr ""

#: ../../sources/guide/inputs.rst:212
msgid "A triple tap is the action of tapping thrice within a time and a distance. It's calculated by the tripletap post-processing module. You can test if the current touch is one of a triple tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:224
msgid "Grabbing touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:226
msgid "It's possible for the parent widget to dispatch a touch event to a child widget from within ``on_touch_down``, but not from ``on_touch_move`` or ``on_touch_up``. This can happen in certain scenarios, like when a touch movement is outside the bounding box of the parent, so the parent decides not to notify its children of the movement."
msgstr ""

#: ../../sources/guide/inputs.rst:232
msgid "But you might want to do something in ``on_touch_up``. Say you started something in the ``on_touch_down`` event, like playing a sound, and you'd like to finish things on the ``on_touch_up`` event. Grabbing is what you need."
msgstr ""

#: ../../sources/guide/inputs.rst:236
msgid "When you grab a touch, you will always receive the move and up event. But there are some limitations to grabbing:"
msgstr ""

#: ../../sources/guide/inputs.rst:239
msgid "You will receive the event at least twice: one time from your parent (the normal event), and one time from the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:241
msgid "You might receive an event with a grabbed touch, but not from you: it can be because the parent has sent the touch to its children while it was in the grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:245
msgid "Here is an example of how to use grabbing::"
msgstr ""

#: ../../sources/guide/inputs.rst:272
msgid "Touch Event Management"
msgstr ""

#: ../../sources/guide/inputs.rst:274
msgid "In order to see how touch events are controlled and propagated between widgets, please refer to the :ref:`Widget touch event bubbling <widget-event-bubbling>` section."
msgstr ""

#: ../../sources/guide/inputs.rst:279
msgid "Joystick events"
msgstr ""

#: ../../sources/guide/inputs.rst:281
msgid "A joystick input represents raw values received directly from physical or virtual controllers through the SDL2 provider via these events:"
msgstr ""

#: ../../sources/guide/inputs.rst:284
msgid "SDL_JOYAXISMOTION"
msgstr ""

#: ../../sources/guide/inputs.rst:285
msgid "SDL_JOYHATMOTION"
msgstr ""

#: ../../sources/guide/inputs.rst:286
msgid "SDL_JOYBALLMOTION"
msgstr ""

#: ../../sources/guide/inputs.rst:287
msgid "SDL_JOYBUTTONDOWN"
msgstr ""

#: ../../sources/guide/inputs.rst:288
msgid "SDL_JOYBUTTONUP"
msgstr ""

#: ../../sources/guide/inputs.rst:290
msgid "Every motion event has a minimum, maximum and default value which can reach:"
msgstr ""

#: ../../sources/guide/inputs.rst:294
msgid "Event"
msgstr ""

#: ../../sources/guide/inputs.rst:294
msgid "Minimum"
msgstr ""

#: ../../sources/guide/inputs.rst:294
msgid "Maximum"
msgstr ""

#: ../../sources/guide/inputs.rst:294
msgid "Default"
msgstr ""

#: ../../sources/guide/inputs.rst:296
msgid "on_joy_axis"
msgstr ""

#: ../../sources/guide/inputs.rst:296
msgid "-32767"
msgstr ""

#: ../../sources/guide/inputs.rst:296
msgid "32767"
msgstr ""

#: ../../sources/guide/inputs.rst:296
msgid "0"
msgstr ""

#: ../../sources/guide/inputs.rst:298
msgid "on_joy_hat"
msgstr ""

#: ../../sources/guide/inputs.rst:298
msgid "(-1, -1)"
msgstr ""

#: ../../sources/guide/inputs.rst:298
msgid "(1, 1)"
msgstr ""

#: ../../sources/guide/inputs.rst:298
msgid "(0, 0)"
msgstr ""

#: ../../sources/guide/inputs.rst:300
msgid "on_joy_ball"
msgstr ""

#: ../../sources/guide/inputs.rst:300
msgid "Unknown"
msgstr ""

#: ../../sources/guide/inputs.rst:303
msgid "Button events, on the other hand represent basically only a state of each button i.e. `up` and `down`, therefore no such values are present."
msgstr ""

#: ../../sources/guide/inputs.rst:306
msgid "on_joy_button_up"
msgstr ""

#: ../../sources/guide/inputs.rst:307
msgid "on_joy_button_down"
msgstr ""

#: ../../sources/guide/inputs.rst:310
msgid "Joystick event basics"
msgstr ""

#: ../../sources/guide/inputs.rst:316
msgid "Unlike touch events, joystick events are dispatched directly to the Window, which means there's only a single value passed for e.g. a specified axis, not multiple ones. This makes things harder if you want to separate input to different widgets, yet not impossible. You can use |dropexpl|_ as an inspiration."
msgstr ""

#: ../../sources/guide/inputs.rst:322
msgid "To get a joystick event, you first need to bind some function to the Window joystick event like this::"
msgstr ""

#: ../../sources/guide/inputs.rst:327
msgid "Then you need to fetch the parameters specified in :class:`~kivy.core.window.Window` for each event you use, for example::"
msgstr ""

#: ../../sources/guide/inputs.rst:333
msgid "A variable `stickid` is an id of a controller that sent the value, `axisid` is an id of an axis to which the value belongs."
msgstr ""

#: ../../sources/guide/inputs.rst:337
msgid "Joystick input"
msgstr ""

#: ../../sources/guide/inputs.rst:339
msgid "Kivy should be able to fetch input from any device specified as `gamepad`, `joystick` or basically any other type of game controller recognized by the SDL2 provider. To make things easier, here are layouts of some common controllers together with ids for each part."
msgstr ""

#: ../../sources/guide/inputs.rst:345
msgid "Xbox 360"
msgstr ""

#: ../../sources/guide/inputs.rst:347
msgid "xbox_ctr"
msgstr ""

#: ../../sources/guide/inputs.rst:360
msgid "|xbox_ctr|"
msgstr ""

#: ../../sources/guide/inputs.rst:351
msgid "#"
msgstr ""

#: ../../sources/guide/inputs.rst:351
msgid "ID"
msgstr ""

#: ../../sources/guide/inputs.rst:353
msgid "1"
msgstr ""

#: ../../sources/guide/inputs.rst:353
msgid "axis 1"
msgstr ""

#: ../../sources/guide/inputs.rst:353
msgid "2"
msgstr ""

#: ../../sources/guide/inputs.rst:353
msgid "axis 0"
msgstr ""

#: ../../sources/guide/inputs.rst:355
msgid "3"
msgstr ""

#: ../../sources/guide/inputs.rst:355
msgid "hat Y"
msgstr ""

#: ../../sources/guide/inputs.rst:355
msgid "4"
msgstr ""

#: ../../sources/guide/inputs.rst:355
msgid "hat X"
msgstr ""

#: ../../sources/guide/inputs.rst:357
msgid "5"
msgstr ""

#: ../../sources/guide/inputs.rst:357
msgid "axis 4"
msgstr ""

#: ../../sources/guide/inputs.rst:357
msgid "6"
msgstr ""

#: ../../sources/guide/inputs.rst:357
msgid "axis 3"
msgstr ""

#: ../../sources/guide/inputs.rst:359
msgid "7"
msgstr ""

#: ../../sources/guide/inputs.rst:359
msgid "axis 2"
msgstr ""

#: ../../sources/guide/inputs.rst:359
msgid "8"
msgstr ""

#: ../../sources/guide/inputs.rst:359
msgid "axis 5"
msgstr ""

#: ../../sources/guide/inputs.rst:361
msgid "9"
msgstr ""

#: ../../sources/guide/inputs.rst:361
msgid "button 4"
msgstr ""

#: ../../sources/guide/inputs.rst:361
msgid "10"
msgstr ""

#: ../../sources/guide/inputs.rst:361
msgid "button 5"
msgstr ""

#: ../../sources/guide/inputs.rst:363
msgid "X"
msgstr ""

#: ../../sources/guide/inputs.rst:363
msgid "button 2"
msgstr ""

#: ../../sources/guide/inputs.rst:363
msgid "Y"
msgstr ""

#: ../../sources/guide/inputs.rst:363
msgid "button 3"
msgstr ""

#: ../../sources/guide/inputs.rst:365
msgid "A"
msgstr ""

#: ../../sources/guide/inputs.rst:365
msgid "button 0"
msgstr ""

#: ../../sources/guide/inputs.rst:365
msgid "B"
msgstr ""

#: ../../sources/guide/inputs.rst:365
msgid "button 1"
msgstr ""

#: ../../sources/guide/inputs.rst:367
msgid "back"
msgstr ""

#: ../../sources/guide/inputs.rst:367
msgid "button 6"
msgstr ""

#: ../../sources/guide/inputs.rst:367
msgid "start"
msgstr ""

#: ../../sources/guide/inputs.rst:367
msgid "button 7"
msgstr ""

#: ../../sources/guide/inputs.rst:369
msgid "center"
msgstr ""

#: ../../sources/guide/inputs.rst:369
msgid "button 10"
msgstr ""

#: ../../sources/guide/inputs.rst:373
msgid "Joystick debugging"
msgstr ""

#: ../../sources/guide/inputs.rst:378
msgid "Mostly you'd want to debug your application with multiple controllers, or test it against _other_ types of controllers (e.g. different brands). As an alternative you might want to use some of the available controller emulators, such as |vjoy|_."
msgstr ""
