# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Kivy 2.2.0.dev0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-12 08:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/api-kivy.clock.rst:3
msgid "Clock object"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:2
msgid "The :class:`Clock` object allows you to schedule a function call in the future; once or repeatedly at specified intervals. You can get the time elapsed between the scheduling and the calling of the callback via the `dt` argument::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:22
msgid "If the callback returns False, the schedule will be canceled and won't repeat."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:25
msgid "If you want to schedule a function to call with default arguments, you can use the `functools.partial <http://docs.python.org/library/functools.html#functools.partial>`_ python module::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:37
msgid "Conversely, if you want to schedule a function that doesn't accept the dt argument, you can use a `lambda <http://docs.python.org/2/reference/expressions.html#lambda>`_ expression to write a short function that does accept dt. For Example::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:49
msgid "You cannot unschedule an anonymous function unless you keep a reference to it. It's better to add \\*args to your function definition so that it can be called with an arbitrary number of parameters."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:56
msgid "The class method callback is weak-referenced: you are responsible for keeping a reference to your original object/callback. If you don't keep a reference, the ClockBase will never execute your callback. For example::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:83
msgid "Schedule before frame"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:87
msgid "Sometimes you need to schedule a callback BEFORE the next frame. Starting from 1.0.5, you can use a timeout of -1::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:93
msgid "The Clock will execute all the callbacks with a timeout of -1 before the next frame even if you add a new callback with -1 from a running callback. However, :class:`Clock` has an iteration limit for these callbacks: it defaults to 10."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:98
msgid "If you schedule a callback that schedules a callback that schedules a ... etc more than 10 times, it will leave the loop and send a warning to the console, then continue after the next frame. This is implemented to prevent bugs from hanging or crashing the application."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:103
msgid "If you need to increase the limit, set the :attr:`max_iteration` property::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:111
msgid "Triggered Events"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:115
msgid ":meth:`CyClockBase.create_trigger` is an advanced method way to defer a callback. It functions exactly like :meth:`CyClockBase.schedule_once` and :meth:`CyClockBase.schedule_interval` except that it doesn't immediately schedule the callback. Instead, one schedules the callback using the :class:`ClockEvent` returned by it. This ensures that you can call the event multiple times but it won't be scheduled more than once. This is not the case with :meth:`CyClockBase.schedule_once`::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:137
msgid "In addition, it is more convenient to create and bind to the triggered event than using :meth:`CyClockBase.schedule_once` in a function::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:153
msgid "Even if x and y changes within one frame, the callback is only run once."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:156
msgid "Unscheduling"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:158
msgid "An event scheduled with :meth:`CyClockBase.schedule_once`, :meth:`CyClockBase.schedule_interval`, or with :meth:`CyClockBase.create_trigger` and then triggered can be unscheduled in multiple ways. E.g::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:185
msgid "The best way to unschedule a callback is with :meth:`ClockEvent.cancel`. :meth:`CyClockBase.unschedule` is mainly an alias for that for that function. However, if the original callback itself is passed to :meth:`CyClockBase.unschedule`, it'll unschedule all instances of that callback (provided ``all`` is True, the default, otherwise only the first match is removed)."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:192
msgid "Calling :meth:`CyClockBase.unschedule` on the original callback is highly discouraged because it's significantly slower than when using the event."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:196
msgid "Clock Lifecycle"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:198
msgid "Kivy's clock has a lifecycle. By default, scheduling a callback after the Clock has ended will not raise an error, even though the callback may never be called. That's because most callbacks are like services, e.g. responding to a user button press - if the app is running the callbacks need to service the app and respond to the input, but once the app has stopped or is stopping, we can safely not process these events."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:205
msgid "Other events always need to be processed. E.g. another thread may request a callback in kivy's thread and then process some result. If the event is not processed in Kivy's thread because the app stopped, the second thread may block forever hanging the application as it exits."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:210
msgid "Consequently, we provide a API (:meth:`CyClockBase.create_lifecycle_aware_trigger`) for scheduling callbacks that raise a :class:`ClockNotRunningError` if the clock has stopped. If the scheduling succeeded it guarantees that one of its callbacks will be called. I.e. the new :meth:`CyClockBase.create_lifecycle_aware_trigger` accepts an additional ``clock_ended_callback`` parameter. Normally, ``callback`` will be called when the event is processed. But, if the clock is stopped before it can be processed, if the application exited normally (and the app was started) and the event wasn't canceled, and the callbacks are not garbage collected, then ``clock_ended_callback`` will be called instead when the clock is stopped."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:221
msgid "That is, given these conditions, if :class:`ClockNotRunningError` was not raised when the event was scheduled, then one of these callbacks will be called - either ``callback`` if the event executed normally, or ``clock_ended_callback`` if the clock is stopped while the event is scheduled."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:226
msgid "By default, events can be scheduled before the clock is started because it is assumed the clock will eventually be started when the app starts. I.e. calling :meth:`CyClockBase.create_lifecycle_aware_trigger` before the clock and application starts will succeed. But if the app never actually starts, then neither of the callbacks may be executed."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:232
msgid "The lifecycle was added in 2.0.0"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:236
msgid "Exception Handling"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:238
msgid "Kivy provides a exception handling manager, :attr:`~kivy.base.ExceptionManager`, to handle its internal exceptions including exceptions raised by clock callbacks, without crashing the application. By default when an exception is raised, the app will crash. But, if a handler is registered with the exception manager and the handler handles the exception, the app will not crash and will continue as normal.::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:255
msgid "Then, all ValueError exceptions will be logged to the console and ignored. Similarly, if a scheduled clock callback raises a ValueError, other clock events will still be processed normally."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:259
msgid "If an event's callback raises an exception, before the exception handler is executed, the callback is immediately canceled."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:262
msgid "It still is possible for the app to be corrupted if kivy itself is the source of the exception. I.e. even with a handler that ignores exceptions and doesn't crash, the app may be in a corrupted state if the error originates from within Kivy itself. However, the exception handler can help protect the app from crashing and can help protect against user callbacks crashing the app."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:268
msgid "Prior to Kivy 2.0.0, an exception raised in a event's callback would cause the clock to crash and subsequent events may or may not be executed. Even if the exception was handled by an :class:`~kivy.base.ExceptionHandler`, there was no guarantee that some scheduled events would not be skipped."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:275
msgid "From 2.0.0 onward, if a event's exception is handled by an :class:`~kivy.base.ExceptionHandler`, other events will be shielded from the exception and will execute normally."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:280
msgid "Scheduling from ``__del__``"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:282
msgid "It is not safe to schedule Clock events from a object's ``__del__`` or ``__dealloc__`` method. If you must schedule a Clock call from this method, use :meth:`CyClockBase.schedule_del_safe` or :meth:`CyClockBase.schedule_lifecycle_aware_del_safe` instead."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:288
msgid "Threading and Callback Order"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:290
msgid "Beginning with 1.10.0, all the events scheduled for the same frame, e.g. all the events scheduled in the same frame with a ``timeout`` of ``0``, well be executed in the order they were scheduled."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:294
msgid "Also, all the scheduling and canceling methods are fully thread safe and can be safely used from external threads."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:297
msgid "As a a consequence, calling :meth:`CyClockBase.unschedule` with the original callback is now significantly slower and highly discouraged. Instead, the returned events should be used to cancel. As a tradeoff, all the other methods are now significantly faster than before."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:303
msgid "Advanced Clock Details"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:305
msgid "The following section goes into the internal kivy clock details as well as the various clock options. It is meant only for advanced users."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:308
msgid "Fundamentally, the Kivy clock attempts to execute any scheduled callback rhythmically as determined by the specified fps (frame per second, see ``maxfps`` in :mod:`~kivy.config`). That is, ideally, given e.g. a desired fps of 30, the clock will execute the callbacks at intervals of 1 / 30 seconds, or every 33.33 ms. All the callbacks in a frame are given the same timestamp, i.e. the ``dt`` passed to the callback are all the same and it's the difference in time between the start of this and the previous frame."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:316
msgid "Because of inherent indeterminism, the frames do not actually occur exactly at intervals of the fps and ``dt`` may be under or over the desired fps. Also, once the timeout is \"close enough\" to the desired timeout, as determined internally, Kivy will execute the callback in the current frame even when the \"actual time\" has not elapsed the ``timeout`` amount."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:322
msgid "Kivy offers now, since ``1.10.0``, multiple clocks with different behaviors."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:325
msgid "Default Clock"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:327
msgid "The default clock (``default``) behaves as described above. When a callback with a timeout of zero or non-zero is scheduled, they are executed at the frame that is near the timeout, which is a function of the fps. So a timeout of zero would still result in a delay of one frame or about 1 / fps, typically a bit less but sometimes more depending on the CPU usage of the other events scheduled for that frame."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:334
msgid "In a test using a fps of 30, a callback with a timeout of 0, 0.001, and 0.05, resulted in a mean callback delay of 0.02487, 0.02488, and 0.05011 seconds, respectively. When tested with a fps of 600 the delay for 0.05 was similar, except the standard deviation was reduced resulting in overall better accuracy."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:340
msgid "Interruptible Clock"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:342
msgid "The default clock suffers from the quantization problem, as frames occur only on intervals and any scheduled timeouts will not be able to occur during an interval. For example, with the timeout of 0.05, while the mean was 0.05011, its values ranged between 0.02548 - 0.07348 and a standard deviation of 0.002. Also, there's the minimum timeout of about 0.02487."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:348
msgid "The interruptible clock (``interrupt``) will execute timeouts even during a frame. So a timeout of zero will execute as quickly as possible and similarly a non-zero timeout will be executed even during the interval."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:352
msgid "This clock, and all the clocks described after this have an option, :attr:`ClockBaseInterruptBehavior.interupt_next_only`. When True, any of the behavior new behavior will only apply to the callbacks with a timeout of zero. Non-zero timeouts will behave like in the default clock. E.g. for this clock when True, only zero timeouts will execute during the the interval."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:358
msgid "In a test using a fps of 30, a callback with a timeout of 0, 0.001, and 0.05, resulted in a mean callback delay of 0.00013, 0.00013, and 0.04120 seconds, respectively when :attr:`ClockBaseInterruptBehavior.interupt_next_only` was False. Also, compared to the default clock the standard deviation was reduced. When :attr:`ClockBaseInterruptBehavior.interupt_next_only` was True, the values were 0.00010, 0.02414, and 0.05034, respectively."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:366
msgid "Free Clock"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:368
msgid "The interruptible clock may not be ideal for all cases because all the events are executed during the intervals and events are not executed anymore rhythmically as multiples of the fps. For example, there may not be any benefit for the graphics to update in a sub-interval, so the additional accuracy wastes CPU."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:374
msgid "The Free clock (``free_all``) solves this by having ``Clock.xxx_free`` versions of all the Clock scheduling methods. By free, we mean the event is free from the fps because it's not fps limited. E.g. :meth:`CyClockBaseFree.create_trigger_free` corresponds to :meth:`CyClockBase.create_trigger`. Only when an event scheduled using the ``Clock.xxx_free`` methods is present will the clock interrupt and execute the events during the interval. So, if no ``free`` event is present the clock behaves like the ``default`` clock, otherwise it behaves like the ``interrupt`` clock."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:384
msgid "In a test using a fps of 30, a callback with a timeout of 0s, 0.001s, and 0.05s, resulted in a mean callback delay of 0.00012s, 0.00017s, and 0.04121s seconds, respectively when it was a free event and 0.02403s, 0.02405s, and 0.04829s, respectively when it wasn't."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:390
msgid "Free Only Clock"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:392
msgid "The Free clock executes all events when a free event was scheduled. This results in normal events also being execute in the middle of the interval when a free event is scheduled. For example, above, when a free event was absent, a normal event with a 0.001s timeout was delayed for 0.02405s. However, if a free event happened to be also scheduled, the normal event was only delayed 0.00014s, which may be undesirable."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:399
msgid "The Free only clock (``free_only``) solves it by only executing free events during the interval and normal events are always executed like with the default clock. For example, in the presence of a free event, a normal event with a timeout of 0.001s still had a delay of 0.02406. So this clock, treats free and normal events independently, with normal events always being fps limited, but never the free events."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:407
msgid "Summary"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:409
msgid "The kivy clock type to use can be set with the ``kivy_clock`` option the :mod:`~kivy.config`. If ``KIVY_CLOCK`` is present in the environment it overwrites the config selection. Its possible values are as follows:"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:413
msgid "When ``kivy_clock`` is ``default``, the normal clock, :class:`ClockBase`, which limits callbacks to the maxfps quantization - is used."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:415
msgid "When ``kivy_clock`` is ``interrupt``, a interruptible clock, :class:`ClockBaseInterrupt`, which doesn't limit any callbacks to the maxfps - is used. Callbacks will be executed at any time."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:418
msgid "When ``kivy_clock`` is ``free_all``, a interruptible clock, :class:`ClockBaseFreeInterruptAll`, which doesn't limit any callbacks to the maxfps in the presence of free events, but in their absence it limits events to the fps quantization interval - is used."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:422
msgid "When ``kivy_clock`` is ``free_only``, a interruptible clock, :class:`ClockBaseFreeInterruptAll`, which treats free and normal events independently; normal events are fps limited while free events are not - is used."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:428
msgid "Async clock support"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:432
msgid "Experimental async support has been added in 2.0.0. The Clock now has a :meth:`ClockBaseBehavior.async_tick` and :meth:`ClockBaseBehavior.async_idle` coroutine method which is used by the kivy EventLoop when the kivy EventLoop is executed in a asynchronous manner. When used, the kivy clock does not block while idling."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:438
msgid "The async library to use is selected with the `KIVY_EVENTLOOP` environmental variable or by  calling :meth:`~kivy.clock.ClockBaseBehavior.init_async_lib` directly. The library can be one of `\"asyncio\"` when the standard library `asyncio` should be used, or `\"trio\"` if the trio library should be used. If not set it defaults to `\"asyncio\"`."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock:444
msgid "See :mod:`~kivy.app` for example usage."
msgstr ""

#: ../../docstring of kivy.clock.Clock:1
msgid "The kivy Clock instance. See module documentation for details."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy.clock.ClockBaseBehavior`, :class:`kivy._clock.CyClockBase`"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBase:1
msgid "The ``default`` kivy clock. See module for details."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBase.usleep:1
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.usleep:1
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptBehavior.usleep:1
msgid "Sleeps for the number of microseconds."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`builtins.object`"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior:1
msgid "The base of the kivy clock."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior:0
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.init_async_lib:0
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptBehavior.init_async_lib:0
#: ../../docstring of kivy.clock.CyClockBase.unschedule:0
msgid "parameters"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior:13
msgid "`async_lib`: string"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior:6
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.init_async_lib:10
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptBehavior.init_async_lib:10
msgid "The async library to use when the clock is run asynchronously. Can be one of, `\"asyncio\"` when the standard library asyncio should be used, or `\"trio\"` if the trio library should be used."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior:10
msgid "It defaults to `'asyncio'` or the value in the environmental variable `KIVY_EVENTLOOP` if set. :meth:`init_async_lib` can also be called directly to set the library."
msgstr ""

#: ../../docstring of kivy.clock.ClockBaseBehavior.MIN_SLEEP:1
msgid "The minimum time to sleep. If the remaining time is less than this, the event loop will continue."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.async_idle:1
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseFreeInterruptOnly.async_idle:1
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptBehavior.async_idle:1
msgid "(internal) async version of :meth:`idle`."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.async_tick:1
msgid "async version of :meth:`tick`."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.frames:1
msgid "Number of internal frames (not necessarily drawn) from the start of the clock."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.frames_displayed:1
msgid "Number of displayed frames from the start of the clock."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.frametime:1
msgid "Time spent between the last frame and the current frame (in seconds)."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.get_boottime:1
msgid "Get the time in seconds from the application start."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.get_fps:1
msgid "Get the current average FPS calculated by the clock."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.get_rfps:1
msgid "Get the current \"real\" FPS calculated by the clock. This counter reflects the real framerate displayed on the screen."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.get_rfps:4
msgid "In contrast to get_fps(), this function returns a counter of the number of frames, not the average of frames per second."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.get_time:1
msgid "Get the last tick made by the clock."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.idle:1
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseFreeInterruptOnly.idle:1
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptBehavior.idle:1
msgid "(internal) waits here until the next frame."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.init_async_lib:1
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptBehavior.init_async_lib:1
msgid "Manually sets the async library to use internally, when running in a asynchronous manner."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.init_async_lib:4
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptBehavior.init_async_lib:4
msgid "This can be called anytime before the kivy event loop has started, but not once the kivy App is running."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.init_async_lib:11
#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptBehavior.init_async_lib:11
msgid "`lib`: string"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.post_idle:1
msgid "Called after :meth:`idle` by :meth:`tick`."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.pre_idle:1
msgid "Called before :meth:`idle` by :meth:`tick`."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.tick:1
msgid "Advance the clock to the next step. Must be called every frame. The default clock has a tick() function called by the core Kivy framework."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.tick_draw:1
msgid "Tick the drawing counter."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseBehavior.time:1
msgid "Proxy method for :func:`~kivy.compat.clock`."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy.clock.ClockBaseInterruptFreeBehavior`, :class:`kivy._clock.CyClockBaseFree`"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseFreeInterruptAll:1
msgid "The ``free_all`` kivy clock. See module for details."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseFreeInterruptOnly:1
msgid "The ``free_only`` kivy clock. See module for details."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy.clock.ClockBaseInterruptBehavior`, :class:`kivy._clock.CyClockBase`"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterrupt:1
msgid "The ``interrupt`` kivy clock. See module for details."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy.clock.ClockBaseBehavior`"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptBehavior:1
msgid "A kivy clock which can be interrupted during a frame to execute events."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy.clock.ClockBaseInterruptBehavior`"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.ClockBaseInterruptFreeBehavior:1
msgid "A base class for the clock that interrupts the sleep interval for free events."
msgstr ""

#: ../../docstring of kivy._clock.ClockEvent:1
msgid "This class is never created by the user; instead, kivy creates and returns an instance of this class when scheduling a callback."
msgstr ""

#: ../../docstring of kivy._clock.ClockEvent:4
msgid "An event can be triggered (scheduled) by calling it. If it's already scheduled, nothing will happen, otherwise it'll be scheduled. E.g.::"
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.callback:1
msgid "callback: object"
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.cancel:1
msgid "Cancels the callback if it was scheduled to be called. If not scheduled, nothing happens."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.cid:1
msgid "cid: object"
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.clock:1
msgid "clock: kivy._clock.CyClockBase The :class:`CyClockBase` instance associated with the event."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.clock_ended_callback:1
msgid "clock_ended_callback: object A Optional callback for this event, which if provided is called by the clock"
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.clock_ended_callback:3
msgid "when the clock is stopped and the event was not ticked."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.get_callback:1
msgid "Returns the callback associated with the event. Callbacks get stored with a indirect ref so that it doesn't keep objects alive. If the callback is dead, None is returned."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.get_clock_ended_callback:1
msgid "Returns the clock_ended_callback associated with the event. Callbacks get stored with a indirect ref so that it doesn't keep objects alive. If the callback is dead or wasn't provided, None is returned."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.is_triggered:1
msgid "Returns whether the event is scheduled to have its callback executed by the kivy thread."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.loop:1
msgid "loop: 'int' Whether this event repeats at intervals of :attr:`timeout`."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.next:1
msgid "next: kivy._clock.ClockEvent The next :class:`ClockEvent` in order they were scheduled."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.prev:1
msgid "prev: kivy._clock.ClockEvent The previous :class:`ClockEvent` in order they were scheduled."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.release:1
msgid "(internal method) Converts the callback into a indirect ref."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.release_ref:1
msgid "release_ref: 'int' If True, the event should never release the reference to the callbacks."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.release_ref:3
msgid "If False, a weakref may be created instead."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.tick:1
msgid "(internal method) Processes the event for the kivy thread."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.timeout:1
msgid "timeout: 'double' The duration after scheduling when the callback should be executed."
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.weak_callback:1
msgid "weak_callback: object"
msgstr ""

#: ../../docstring of kivy.clock.ClockEvent.weak_clock_ended_callback:1
msgid "weak_clock_ended_callback: object"
msgstr ""

#: ../../docstring of kivy._clock.ClockNotRunningError:1
msgid "Bases: :py:class:`RuntimeError`"
msgstr ""

#: ../../docstring of kivy._clock.ClockNotRunningError:1
msgid "Raised by the kivy Clock when scheduling an event if the Kivy Clock has already finished (:class:`~CyClockBase.stop_clock` was called)."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.clock_resolution:1
msgid "clock_resolution: 'double' If the remaining time until the event timeout is less than :attr:`clock_resolution`,"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.clock_resolution:3
msgid "the clock will execute the callback even if it hasn't exactly timed out."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.clock_resolution:5
msgid "If -1, the default, the resolution will be computed from config's ``maxfps``. Otherwise, the provided value is used. Defaults to -1."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:1
msgid "Create a Trigger event similarly to :meth:`create_trigger`, but the event is sensitive to the clock's state."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:4
msgid "If this event is triggered after the clock has stopped (:meth:`stop_clock`), then a :class:`ClockNotRunningError` will be raised. If the error is not raised, then either ``callback`` or ``clock_ended_callback`` will be called. ``callback`` will be called when the event is normally executed. If the clock is stopped before it can be executed, provided the app exited normally without crashing and the event wasn't manually canceled, and the callbacks are not garbage collected then ``clock_ended_callback`` will be called instead when the clock is stopped."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:0
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:0
#: ../../docstring of kivy.clock.CyClockBase.handle_exception:0
#: ../../docstring of kivy.clock.CyClockBase.schedule_del_safe:0
#: ../../docstring of kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:0
msgid "Parameters"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:16
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:13
msgid "`callback`: callable"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:16
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:13
msgid "The callback to execute from kivy. It takes a single parameter - the current elapsed kivy time."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:23
#: ../../docstring of kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:23
msgid "`clock_ended_callback`: callable"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:19
msgid "A callback that will be called if the clock is stopped while the event is still scheduled to be called. The callback takes a single parameter - the event object. When the event is successfully scheduled, if the app exited normally and the event wasn't canceled, and the callbacks are not garbage collected - it is guaranteed that either ``callback`` or ``clock_ended_callback`` would have been called."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:25
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:15
msgid "`timeout`: float"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:26
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:16
msgid "How long to wait before calling the callback."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:28
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:18
msgid "`interval`: bool"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:28
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:18
msgid "Whether the callback should be called once (False) or repeatedly with a period of ``timeout`` (True) like :meth:`schedule_interval`."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:35
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:25
msgid "`release_ref`: bool"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:31
msgid "If True, the default, then if ``callback`` or ``clock_ended_callback`` is a class method and the object has no references to it, then the object may be garbage collected and the callbacks won't be called. If False, the clock keeps a reference to the object preventing it from being garbage collected - so it will be called."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:0
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:0
#: ../../docstring of kivy.clock.CyClockBase.schedule_interval:0
#: ../../docstring of kivy.clock.CyClockBase.schedule_once:0
msgid "Returns"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_lifecycle_aware_trigger:37
#: ../../docstring of kivy.clock.CyClockBase.create_trigger:27
msgid "A :class:`ClockEvent` instance. To schedule the callback of this instance, you can call it."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_trigger:1
msgid "Create a Trigger event. It is thread safe but not ``__del__`` or ``__dealloc__`` safe (see :meth:`schedule_del_safe`). Check module documentation for more information."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_trigger:5
msgid "To cancel the event before it is executed, call :meth:`ClockEvent.cancel` on the returned event. To schedule it again, simply call the event (``event()``) and it'll be safely rescheduled if it isn't already scheduled."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_trigger:21
msgid "If True, the default, then if ``callback`` is a class method and the object has no references to it, then the object may be garbage collected and the callbacks won't be called. If False, the clock keeps a reference to the object preventing it from being garbage collected - so it will be called."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_trigger:36
msgid "``interval`` has been added."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.create_trigger:40
msgid "``release_ref`` has been added."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.get_before_frame_events:1
msgid "Returns the list of :class:`ClockEvent` instances that are scheduled to be called before the next frame (``-1`` timeout)."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.get_events:1
msgid "Returns the list of :class:`ClockEvent` instances currently scheduled."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.get_min_timeout:1
msgid "Returns the remaining time since the start of the current frame for the event with the smallest timeout."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.get_resolution:1
msgid "Returns the minimum resolution the clock has. It's a function of :attr:`clock_resolution` and ``maxfps`` provided at the config."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.handle_exception:1
msgid "Provides an opportunity to handle an event's exception."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.handle_exception:3
msgid "If desired, the exception is handled, otherwise it should be raised again. By default it is raised again."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.handle_exception:6
msgid "The exception to be handled."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.has_ended:1
msgid "has_ended: 'int'"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.has_started:1
msgid "has_started: 'int'"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.max_iteration:1
msgid "max_iteration: 'int' The maximum number of callback iterations at the end of the frame, before the next"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.max_iteration:3
msgid "frame. If more iterations occur, a warning is issued."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.on_schedule:1
msgid "Function that is called internally every time an event is triggered for this clock. It takes the event as a parameter."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.on_schedule:4
msgid "The order of ``on_schedule`` calls are not guaranteed to be in the same order that the events are scheduled. Similarly, it is possible that the event being scheduled was canceled before this is called on the event. That's because :meth:`on_schedule` may be called from different threads."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_del_safe:1
msgid "Schedule a callback that is thread safe and ``__del__`` or ``__dealloc__`` safe."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_del_safe:4
msgid "It's unsafe to call various kinds of code from ``__del__`` or ``__dealloc__`` methods because they can be executed at any time. Most Kivy's Clock methods are unsafe to call the Clock from these methods. Instead, use this method, which is thread safe and ``__del__`` or ``__dealloc__`` safe, to schedule the callback in the kivy thread. It'll be executed in order after the normal events are processed."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_del_safe:15
#: ../../docstring of kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:16
msgid "`callback`: Callable"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_del_safe:14
#: ../../docstring of kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:16
msgid "The callback the execute from kivy. It takes no parameters and cannot be canceled."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_interval:1
msgid "Schedule an event to be called every <timeout> seconds. See :meth:`create_trigger` for advanced scheduling and more details."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_interval:4
#: ../../docstring of kivy.clock.CyClockBase.schedule_once:5
msgid "To cancel the event before it is executed, call :meth:`ClockEvent.cancel` on the returned event. If the callback is a class method, a weakref to the object is created and it may be garbage collected if there's no other reference to the object."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_interval:9
#: ../../docstring of kivy.clock.CyClockBase.schedule_once:10
msgid "A :class:`ClockEvent` instance. As opposed to :meth:`create_trigger` which only creates the trigger event, this method also schedules it."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:1
msgid "Schedule a callback that is thread safe and ``__del__`` or ``__dealloc__`` safe similarly to :meth:`schedule_del_safe`, but the callback is sensitive to the clock's state."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:5
msgid "If this event is triggered after the clock has stopped (:meth:`stop_clock`), then a :class:`ClockNotRunningError` will be raised. If the error is not raised, then either ``callback`` or ``clock_ended_callback`` will be called. ``callback`` will be called when the callback is normally executed. If the clock is stopped before it can be executed, provided the app exited normally without crashing then ``clock_ended_callback`` will be called instead when the clock is stopped."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_lifecycle_aware_del_safe:19
msgid "A callback that will be called if the clock is stopped while the callback is still scheduled to be called. The callback takes a single parameter - the callback. If the app exited normally, it is guaranteed that either ``callback`` or ``clock_ended_callback`` would have been called."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_once:1
msgid "Schedule an event in <timeout> seconds. If <timeout> is unspecified or 0, the callback will be called after the next frame is rendered. See :meth:`create_trigger` for advanced scheduling and more details."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.schedule_once:16
msgid "If the timeout is -1, the callback will be called before the next frame (at :meth:`tick_draw`)."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.start_clock:1
msgid "Must be called to start the clock."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.start_clock:3
msgid "Once :meth:`stop_clock` is called, it cannot be started again."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.stop_clock:1
msgid "Stops the clock and cleans up."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.stop_clock:3
msgid "This must be called to process the lifecycle_aware callbacks etc."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.unschedule:1
msgid "Remove a previously scheduled event."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.unschedule:3
msgid "An :class:`ClockEvent` can also be canceled directly by calling :meth:`ClockEvent.cancel`."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.unschedule:19
msgid "`callback`: :class:`ClockEvent` or a callable."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.unschedule:9
msgid "If it's a :class:`ClockEvent` instance, then the callback associated with this event will be canceled if it is scheduled."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.unschedule:13
msgid "If it's a callable, then the callable will be unscheduled if it was scheduled."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.unschedule:18
msgid "Passing the callback function rather than the returned :class:`ClockEvent` will result in a significantly slower unscheduling."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.unschedule:24
msgid "`all`: bool"
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.unschedule:22
msgid "If True and if `callback` is a callable, all instances of this callable will be unscheduled (i.e. if this callable was scheduled multiple times). Defaults to `True`."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBase.unschedule:26
msgid "The all parameter was added. Before, it behaved as if `all` was `True`."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy._clock.CyClockBase`"
msgstr ""

#: ../../docstring of kivy._clock.CyClockBaseFree:1
msgid "A clock class that supports scheduling free events in addition to normal events."
msgstr ""

#: ../../docstring of kivy._clock.CyClockBaseFree:4
msgid "Each of the :meth:`~CyClockBase.create_trigger`, :meth:`~CyClockBase.schedule_once`, and :meth:`~CyClockBase.schedule_interval` methods, which create a normal event, have a corresponding method for creating a free event."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBaseFree.create_lifecycle_aware_trigger_free:1
msgid "Similar to :meth:`~CyClockBase.create_lifecycle_aware_trigger`, but instead creates a free event."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBaseFree.create_trigger_free:1
msgid "Similar to :meth:`~CyClockBase.create_trigger`, but instead creates a free event."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBaseFree.get_min_free_timeout:1
msgid "Returns the remaining time since the start of the current frame for the *free* event with the smallest timeout."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBaseFree.schedule_interval_free:1
msgid "Similar to :meth:`~CyClockBase.schedule_interval`, but instead creates a free event."
msgstr ""

#: ../../docstring of kivy.clock.CyClockBaseFree.schedule_once_free:1
msgid "Similar to :meth:`~CyClockBase.schedule_once`, but instead creates a free event."
msgstr ""

#: ../../<autodoc>:1
msgid "Bases: :class:`kivy._clock.ClockEvent`"
msgstr ""

#: ../../docstring of kivy._clock.FreeClockEvent:1
msgid ":class:`CyClockBaseFree`. It stores whether the event was scheduled as a free event."
msgstr ""

#: ../../docstring of kivy.clock.FreeClockEvent.free:1
msgid "free: 'int' Whether this event was scheduled as a free event."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.mainthread:1
msgid "Decorator that will schedule the call of the function for the next available frame in the mainthread. It can be useful when you use :class:`~kivy.network.urlrequest.UrlRequest` or when you do Thread programming: you cannot do any OpenGL-related work in a thread."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.mainthread:6
msgid "Please note that this method will return directly and no result can be returned::"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.triggered:1
msgid "Decorator that will trigger the call of the function at the specified timeout, through the method :meth:`CyClockBase.create_trigger`. Subsequent calls to the decorated function (while the timeout is active) are ignored."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.triggered:5
msgid "It can be helpful when an expensive function (i.e. call to a server) can be triggered by different methods. Setting a proper timeout will delay the calling and only one of them will be triggered."
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.triggered:9
msgid "@triggered(timeout, interval=False) def callback(id):"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.triggered:11
msgid "print('The callback has been called with id=%d' % id)"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.triggered:13
msgid ">> callback(id=1) >> callback(id=2) The callback has been called with id=2"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.triggered:17
msgid "The decorated callback can also be unscheduled using:"
msgstr ""

#: ../../../kivy/clock.py:docstring of kivy.clock.triggered:19
msgid ">> callback.cancel()"
msgstr ""
